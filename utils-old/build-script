#!/usr/bin/env python

# utils/build-script ----------------------------------------------*- python -*-
#
# This source file is part of the Unsung Anthem open source project.
#
# Copyright (c) 2017 Venturesome Stone
# Licensed under GNU Affero General Public License v3.0

import argparse
import json
import multiprocessing
import os
import sys
import time

from anthem_build_support.anthem_build_support import \
    arguments, checkout, diagnostics, migration, shell

from anthem_build_support.anthem_build_support.presets import \
    get_all_preset_names, get_preset_options

from anthem_build_support.anthem_build_support.variables import \
    HOME, ANTHEM_BUILD_ROOT, ANTHEM_SOURCE_ROOT, ANTHEM_REPO_NAME, SCRIPT_DIR

from anthem_build_support.anthem_build_support.targets import DeploymentTarget

from anthem_build_support.anthem_build_support.toolchain import \
    register_tools, host_toolchain

from anthem_build_support.anthem_build_support.workspace import \
    Workspace, compute_build_subdir, compute_install_prefix, \
    compute_shared_build_subdir, compute_shared_install_prefix

from anthem_build_support.anthem_build_support.products import \
    anthem, cat, catch, cmake, docs, gcc, glfw, llvm, ninja, sdl, spdlog


program_description = """
Use this tool to build, test, and prepare binary distribution archives of
Unsung Anthem.

Builds Unsung Anthem and its dependencies, incrementally, optionally testing
Unsung Anthem thereafter. Different build configurations are maintained in
parallel."""

program_epilogue = """
Using option presets:

  --preset-file=PATH    load presets from the specified file

  --preset=NAME         use the specified option preset

  The preset mode is mutually exclusive with other options. It is not possible
  to add ad-hoc customizations to a preset. This is a deliberate design
  decision. (Rationale: a preset is a certain important set of options that is
  wanted to be kept in a centralized location. If one needs to customize it,
  one should create another preset in a centralized location, rather than
  scattering the knowledge about the build across the system.)

  Presets support substitutions for controlled customizations. Substitutions
  are defined in the preset file. Values for substitutions are supplied using
  the name=value syntax on the command line.


Environment variables
---------------------

This script respects a few environment variables, should one choose to set
them:

ANTHEM_SOURCE_ROOT: a directory containing the source for Unsung Anthem. If
                    this script is located in an Unsung Anthem source
                    directory, the location of ANTHEM_SOURCE_ROOT will be
                    inferred if the variable is not set.

'build-script' expects the sources to be laid out in the following way:

   $ANTHEM_SOURCE_ROOT/unsung-anthem (the directory name does not matter)

ANTHEM_SOURCE_ROOT: a directory in which to create out-of-tree builds. Defaults
                    to "$ANTHEM_SOURCE_ROOT/build/".

Preparing to run this script
----------------------------

Make sure that your system has C and C++ compiler.

That's it; you're ready to go!

Examples
--------

Given the above layout of sources, the simplest invocation of 'build-script' is
just:

  [~/src/s]$ ./unsung-anthem/utils/build-script

This builds Unsung Anthem, its dependencies and the tools required to build in
debug mode.

All builds are incremental. To incrementally build changed files, repeat the
same 'build-script' command.

Typical uses of 'build-script'
------------------------------

To build everything with optimization without debug information:

  [~/src/s]$ ./unsung-anthem/utils/build-script -R

To run tests, add '-t':

  [~/src/s]$ ./unsung-anthem/utils/build-script -R -t

To build dependencies and tools with optimization without debug information,
and debuggable Unsung Anthem:

  [~/src/s]$ ./unsung-anthem/utils/build-script -R --debug-anthem

To use 'make' instead of 'ninja', use '-m':

  [~/src/s]$ ./unsung-anthem/utils/build-script -m -R

To create Xcode projects that can build Unsung Anthem, use '-x':

  [~/src/s]$ ./unsung-anthem/utils/build-script -x -R

Preset mode in build-script
---------------------------

All buildbots and automated environments use 'build-script' in *preset mode*.
In preset mode, the command line only specifies the preset name and allows
limited customization (extra output paths). The actual options come from the
selected preset in 'utils/build-presets.ini'.

If you have your own favourite set of options, you can create your own, local,
preset. For example, let us create a preset called 'dua' (which stands for
Debug Unsung Anthem):

  $ cat > ~/.anthem-build-presets
  [preset: dua]
  release
  debug-anthem
  test
  build-subdir=dua

To use it, specify the '--preset=' argument:

  [~/src/s]$ ./unsung-anthem/utils/build-script --preset=dua
  ./unsung-anthem/utils/build-script: using preset 'dua', which expands to
  ./unsung-anthem/utils/build-script --release --debug-anthem --test \
--build-subdir=dua --
  ...

Philosophy
----------

While one can invoke CMake directly to build Unsung Anthem, this tool will save
one's time by taking away the mechanical parts of the process, providing one
the controls for the important options.

For all automated build environments, this tool is regarded as *the* *only* way
to build Unsung Anthem. This is not a technical limitation of the Unsung Anthem
build system. It is a policy decision aimed at making the builds uniform across
all environments and easily reproducible by engineers who are not familiar with
the details of the setups of other systems or automated environments.
"""


def exit_rejecting_arguments(message, parser=None):
    print(message)  # TODO , file=sys.stderr)
    if parser:
        parser.print_usage(sys.stderr)
    sys.exit(2)  # 2 is the same as `argparse` error exit code.


def apply_default_ci_arguments(args):
    # If the build is done in Travis, CircleCI, or AppVeyor, CI is true.
    if args.travis or args.circleci or args.appveyor:
        args.ci = True


def apply_default_cxx_std_arguments(args):
    # If the build is done in a CI environment and the compiler is Clang,
    # default to libc++.
    if args.stdlib is None and args.ci and args.main_tool == 'llvm':
        args.stdlib = 'libc++'

    # If LLVM or libc++ is being built, the library should be set to libc++.
    if (args.build_llvm or args.build_libcxx) and args.stdlib is None:
        args.stdlib = 'libc++'

    # If GCC is being built, the library should be set to libstdc++.
    if args.build_gcc and args.stdlib is None:
        args.stdlib = 'libstdc++'

    # Set the C++ standard library implementation and a flag denoting whether
    # or not it is set.
    if args.stdlib is None:
        args.stdlib_set = False
    else:
        args.stdlib_set = True


def apply_default_arguments(args):
    if args.install_only:
        args.build_only = False
        args.test_only = False
        args.update_checkout_only = False
        args.docs_only = False
    elif args.build_only:
        args.install_only = False
        args.test_only = False
        args.update_checkout_only = False
        args.docs_only = False
    elif args.test_only:
        args.build_only = False
        args.install_only = False
        args.update_checkout_only = False
        args.docs_only = False
    elif args.update_checkout_only:
        args.build_only = False
        args.install_only = False
        args.test_only = False
        args.docs_only = False
    elif args.docs_only:
        args.build_only = False
        args.install_only = False
        args.test_only = False
        args.update_checkout_only = False

    # If SDL or GLFW is not explicitly specified, use GLFW.
    if not args.sdl and not args.glfw:
        args.sdl = False
        args.glfw = True

    # Build LLVM if any LLVM-related options were specified.
    if args.llvm_build_variant is not None or args.llvm_assertions is not None:
        args.build_llvm = True

    # The default build variant is Debug.
    if args.build_variant is None:
        args.build_variant = 'Debug'

    # Propagate the build variant.
    if args.llvm_build_variant is None:
        args.llvm_build_variant = args.build_variant

    if args.libcxx_build_variant is None:
        args.libcxx_build_variant = args.build_variant

    if args.anthem_build_variant is None:
        args.anthem_build_variant = args.build_variant

    if args.sdl_build_variant is None:
        args.sdl_build_variant = args.build_variant

    if args.glfw_build_variant is None:
        args.glfw_build_variant = args.build_variant

    # Assertions are enabled by default.
    if args.assertions is None:
        args.assertions = True

    # Propagate the assertion option.
    if args.llvm_assertions is None:
        args.llvm_assertions = args.assertions

    if args.libcxx_assertions is None:
        args.libcxx_assertions = args.assertions

    if args.anthem_assertions is None:
        args.anthem_assertions = args.assertions

    # The default CMake generator is Ninja.
    if args.cmake_generator is None:
        args.cmake_generator = 'Ninja'

    # The only CMake generator with gcov is make.
    if args.enable_gcov:
        args.cmake_generator = 'Unix Makefiles'

    # The default CMake generator on CLion is make.
    if args.clion:
        args.cmake_generator = 'Unix Makefiles'

    # Propagate --run-test.
    if args.test_only:
        args.clean = False
        args.clean_build = False

    # Propagate --clean.
    if args.clean:
        args.clean_build = True
        args.clean_shared = True

    if args.clion:
        args.test = False
        args.test_optimized = False
        args.build_test = False
        args.build_test_optimized = False

    # --test-optimized implies --test and --build-test-optimized.
    if args.test_optimized:
        args.test = True
        args.build_test_optimized = True

    # --test implies --build-test.
    if args.test:
        args.build_test = True

    # By default, Ninja is not built on AppVeyor.
    if not args.build_ninja \
            and args.cmake_generator == 'Visual Studio 14 2015':
        args.build_ninja = False

    # Propagate global --skip-build
    if args.skip_build:
        args.skip_build_anthem = True
        args.build_llvm = False
        args.build_gcc = False
        args.build_libcxx = False
        args.build_cmake = False
        args.build_ninja = False
        args.build_test = False
        args.build_test_optimized = False

    # If the LLVM is built, there is no need for explicitly building libc++.
    if args.build_llvm:
        args.build_libcxx = False

    # Set the default GCC mirror.
    if args.gcc_mirror == 'default':
        with open(args.build_config) as f:
            config = json.load(f)

        asset_node = config['dependencies']['gcc']['asset']
        args.gcc_mirror = asset_node['default_mirror']

    if args.disable_shared_tools:
        args.share_tools = False
    else:
        args.share_tools = True

    # Set the Visual Studio option to true if the CMake generator is Visual
    # Studio.
    if args.cmake_generator.startswith('Visual Studio'):
        args.visual_studio = True
    else:
        args.visual_studio = False


def apply_default_version_arguments(args):
    with open(args.build_config) as f:
        config = json.load(f)

    if args.anthem_version == 'default':
        args.anthem_version = config['version']

    args.version_info['anthem'] = args.anthem_version

    dependencies = config['dependencies']

    if args.llvm_version == 'default':
        llvm_node = dependencies['llvm']
        args.llvm_version = llvm_node['default_version']

        if args.llvm_version == "git":
            args.llvm_version = "6.0.0svn"

    args.version_info['llvm'] = args.llvm_version

    if args.gcc_version == 'default':
        gcc_node = dependencies['gcc']
        args.gcc_version = gcc_node['default_version']

    args.version_info['gcc'] = args.gcc_version

    cmake_node = dependencies['cmake']

    if args.cmake_version == 'default':
        if args.cmake_major_version == 'default':
            args.cmake_major_version = \
                int(cmake_node['default_version']['major'])

        if args.cmake_minor_version == 'default':
            args.cmake_minor_version = \
                int(cmake_node['default_version']['minor'])

        if args.cmake_patch_version == 'default':
            args.cmake_patch_version = \
                int(cmake_node['default_version']['patch'])

        if args.cmake_minor_patch_version == 'default':
            if "minor_patch" in cmake_node['default_version']:
                try:
                    minor_patch = \
                        int(cmake_node['default_version']['minor_patch'])

                    if minor_patch == 0:
                        args.cmake_minor_patch_version = None
                    else:
                        args.cmake_minor_patch_version = minor_patch
                except ValueError:
                    args.cmake_minor_patch_version = None

        if args.cmake_minor_patch_version is None:
            args.cmake_version = "{}.{}.{}".format(args.cmake_major_version,
                                                   args.cmake_minor_version,
                                                   args.cmake_patch_version)
        else:
            args.cmake_version = "{}.{}." \
                                 "{}.{}".format(args.cmake_major_version,
                                                args.cmake_minor_version,
                                                args.cmake_patch_version,
                                                args.cmake_minor_patch_version)
    else:
        if len(args.cmake_version.split('.')) == 3:
            args.cmake_major_version = int(args.cmake_version.split('.')[0])
            args.cmake_minor_version = int(args.cmake_version.split('.')[1])
            args.cmake_patch_version = int(args.cmake_version.split('.')[2])
        elif len(args.cmake_version.split('.')) == 4:
            args.cmake_major_version = int(args.cmake_version.split('.')[0])
            args.cmake_minor_version = int(args.cmake_version.split('.')[1])
            args.cmake_patch_version = int(args.cmake_version.split('.')[2])
            args.cmake_minor_patch_version = \
                int(args.cmake_version.split('.')[3])

    args.version_info['cmake'] = args.cmake_version

    args.version_info['cmake_info'] = {
        'major': args.cmake_major_version,
        'minor': args.cmake_minor_version,
        'patch': args.cmake_patch_version
    }

    if args.ninja_version == 'default':
        ninja_node = dependencies['ninja']
        args.ninja_version = ninja_node['default_version']

    args.version_info['ninja'] = args.ninja_version

    if args.catch_version == 'default':
        catch_node = dependencies['catch']
        args.catch_version = catch_node['default_version']

    args.version_info['catch'] = args.catch_version

    if args.sdl_version == 'default':
        sdl_node = dependencies['sdl']
        args.sdl_version = sdl_node['default_version']

    args.version_info['sdl'] = args.sdl_version

    if args.glfw_version == 'default':
        glfw_node = dependencies['glfw']
        args.glfw_version = glfw_node['default_version']

    args.version_info['glfw'] = args.glfw_version

    if args.spdlog_version == 'default':
        spdlog_node = dependencies['spdlog']
        args.spdlog_version = spdlog_node['default_version']

    args.version_info['spdlog'] = args.spdlog_version

    if args.cat_version == 'default':
        cat_node = dependencies['cat']
        args.cat_version = cat_node['default_version']

    args.version_info['cat'] = args.cat_version


def apply_default_checkout_skip_arguments(args, toolchain):
    # Skip LLVM on the checkout update if LLVM will not be built.
    if not args.build_llvm:
        if not args.build_libcxx:
            args.skip_repository_list += ['llvm']
        else:
            args.skip_repository_list += ['llvm-clang']
            args.skip_repository_list += ['llvm-llvm']

    # Skip GCC on the checkout update if GCC will not be built.
    if not args.build_gcc:
        args.skip_repository_list += ['gcc']

    # Skip CMake on the checkout update if CMake will not be built.
    if not args.build_cmake and toolchain.cmake is not None:
        args.skip_repository_list += ['cmake']

    # Skip Ninja on the checkout update if Ninja will not be built.
    if not args.build_ninja and toolchain.ninja is not None:
        args.skip_repository_list += ['ninja']

    # Skip Catch on the checkout update if the tests are not built.
    if not args.build_test:
        args.skip_repository_list += ['catch']

    # Skip SDL on the checkout update if it is not used.
    if not args.sdl:
        args.skip_repository_list += ['sdl']

    # Skip GLFW on the checkout update if it is not used.
    if not args.glfw:
        args.skip_repository_list += ['glfw']


def apply_default_file_arguments(args):
    # Set the build subdirectory.
    if args.build_subdir is None:
        args.build_subdir = compute_build_subdir(args)

    # Set the tool build subdirectory.
    if not args.share_tools:
        args.tool_build_subdir = args.build_subdir
    else:
        if args.tool_build_subdir is None:
            args.tool_build_subdir = compute_shared_build_subdir(args)

    # Set the installation subdirectory.
    if args.install_prefix is None:
        if not args.share_tools:
            args.install_prefix = compute_install_prefix(args)
        else:
            args.install_prefix = compute_shared_install_prefix(args)

    # Set the executable name.
    if args.executable_name is None:
        args.executable_name = 'unsung-anthem-{}'.format(args.host_target)

    # Set the test executable name.
    if args.test_executable_name is None:
        args.test_executable_name = 'test-{}'.format(args.executable_name)


def validate_arguments(args):
    # Check the validity of C++ standard version.
    if not ('latest' == args.std
            or 'c++latest' == args.std
            or 'c++2a' == args.std
            or 'c++17' == args.std
            or 'c++14' == args.std):
        exit_rejecting_arguments('C++ standard version is set to an invalid '
                                 'value: ' + str(args.cmake_generator))

    # Check the validity of C++ standard library.
    if args.stdlib_set:
        if not (args.stdlib == 'libc++' or args.stdlib == 'libstdc++'):
            exit_rejecting_arguments('C++ standard library implementation is '
                                     'set to an invalid value: '
                                     + str(args.cmake_generator))

    # Check the validity of CMake generator.
    if not ('Ninja' == args.cmake_generator
            or 'Unix Makefiles' == args.cmake_generator
            or 'Xcode' == args.cmake_generator
            or 'Visual Studio 14 2015' == args.cmake_generator
            or 'Visual Studio 15 2017' == args.cmake_generator
            or 'Eclipse CDT4 - Ninja' == args.cmake_generator):
        exit_rejecting_arguments('CMake generator is set to an invalid value: '
                                 + str(args.cmake_generator))

    # Check the validity of the collective build variant.
    if not ('Debug' == args.build_variant
            or 'RelWithDebInfo' == args.build_variant
            or 'Release' == args.build_variant):
        exit_rejecting_arguments('Build variant is set to an invalid value: '
                                 + str(args.build_variant))

    # Check the validity of the LLVM build variant.
    if not ('Debug' == args.llvm_build_variant
            or 'RelWithDebInfo' == args.llvm_build_variant
            or 'Release' == args.llvm_build_variant):
        exit_rejecting_arguments('LLVM build variant is set to an invalid '
                                 'value: ' + str(args.llvm_build_variant))

    # Check the validity of the libc++ build variant.
    if not ('Debug' == args.libcxx_build_variant
            or 'RelWithDebInfo' == args.libcxx_build_variant
            or 'Release' == args.libcxx_build_variant):
        exit_rejecting_arguments('libc++ build variant is set to an invalid '
                                 'value: ' + str(args.llvm_build_variant))

    # Check the validity of the Unsung Anthem build variant.
    if not ('Debug' == args.anthem_build_variant
            or 'RelWithDebInfo' == args.anthem_build_variant
            or 'Release' == args.anthem_build_variant):
        exit_rejecting_arguments('Unsung Anthem build variant is set to an '
                                 'invalid value: '
                                 + str(args.anthem_build_variant))

    # Check the validity of the SDL build variant.
    if not ('Debug' == args.sdl_build_variant
            or 'RelWithDebInfo' == args.sdl_build_variant
            or 'Release' == args.sdl_build_variant):
        exit_rejecting_arguments('SDL build variant is set to an invalid '
                                 'value: '
                                 + str(args.anthem_build_variant))

    # Check the validity of the GLFW build variant.
    if not ('Debug' == args.glfw_build_variant
            or 'RelWithDebInfo' == args.glfw_build_variant
            or 'Release' == args.glfw_build_variant):
        exit_rejecting_arguments('GLFW build variant is set to an '
                                 'invalid value: '
                                 + str(args.anthem_build_variant))

    # Check the validity of the compiler tool to be looked for.
    if not ('clang' == args.main_tool
            or args.main_tool == 'llvm'
            or 'gcc' == args.main_tool
            or 'msbuild' == args.main_tool):
        exit_rejecting_arguments('The main tool is set to an invalid value: '
                                 + str(args.anthem_build_variant))

    # Check that both LLVM and GCC are not built at the same time.
    if args.build_llvm and args.build_gcc:
        exit_rejecting_arguments('Both LLVM and GCC cannot be built at the '
                                 'same time')

    # Check that both LLVM and libc++ are npt built at the same time as LLVM
    # build anyway builds libc++.
    if args.build_llvm and args.build_libcxx:
        exit_rejecting_arguments('Both LLVM and libc++ cannot be built at the '
                                 'same time')

    # Check that both SDL and GLFW cannot be used at the same time.
    if args.sdl and args.glfw:
        exit_rejecting_arguments('Both SDL and GLFW cannot be used at the '
                                 'same time')


def parse_git_versions(args):
    args.llvm_version = checkout.parse_git_version(args.llvm_version)
    args.version_info['llvm'] = args.llvm_version

    # GCC cannot be obtained via git.

    # CMake cannot be obtained via git.

    args.ninja_version = checkout.parse_git_version(args.ninja_version)
    args.version_info['ninja'] = args.ninja_version

    args.catch_version = checkout.parse_git_version(args.catch_version)
    args.version_info['catch'] = args.catch_version

    # SDL cannot be obtained via git.

    args.glfw_version = checkout.parse_git_version(args.glfw_version)
    args.version_info['glfw'] = args.glfw_version

    args.spdlog_version = checkout.parse_git_version(args.spdlog_version)
    args.version_info['spdlog'] = args.spdlog_version

    args.cat_version = checkout.parse_git_version(args.cat_version)
    args.version_info['cat'] = args.cat_version


def initialize_runtime_environment():
    """
    Change the program environment for building.
    """

    # Set an appropriate default umask.
    os.umask(0o022)

    # Unset environment variables that might affect how tools behave.
    for s in ['MAKEFLAGS']:
        os.environ.pop(s, None)


def clean_delay():
    """
    Provide a short delay so accidentally invoked clean builds can be
    cancelled.

    :return:
    """

    sys.stdout.write('Starting clean build in  ')

    for i in range(3, 0, -1):
        sys.stdout.write('\b%d' % i)
        sys.stdout.flush()
        time.sleep(1)

    print('\b\b\b\bnow.')


def main_preset():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description="""Builds Unsung Anthem using a preset.""")
    parser.add_argument(
        "-n", "--dry-run",
        help="print the commands that would be executed, but do not execute "
             "them",
        action="store_true",
        default=False)

    clean_group = parser.add_mutually_exclusive_group(required=False)
    clean_group.add_argument(
        "-c", "--clean",
        help="do a clean build",
        action="store_true")
    clean_group.add_argument(
        "--clean-build",
        help="do a clean build but do not redownload the dependencies",
        action="store_true")
    clean_group.add_argument(
        "--clean-shared",
        help="delete only the shared build",
        action="store_true")

    parser.add_argument(
        "--preset-file",
        help="load presets from the specified file",
        metavar="PATH",
        action="append",
        dest="preset_file_names",
        default=[])
    parser.add_argument(
        "--preset",
        help="use the specified option preset",
        metavar="NAME",
        required=True)
    parser.add_argument(
        "--show-presets",
        help="list all presets and exit",
        action=arguments.action.optional_bool)

    build_actions_group = parser.add_mutually_exclusive_group(required=False)
    build_actions_group.add_argument(
        "--install",
        help="only install the project dependencies",
        action="store_true",
        dest="install_only")
    build_actions_group.add_argument(
        "--build",
        help="build the project without installing the dependencies",
        action="store_true",
        dest="build_only")
    build_actions_group.add_argument(
        "--run-test",
        help="run the tests without installing the dependencies or building "
             "the project",
        action="store_true",
        dest="test_only")
    build_actions_group.add_argument(
        "--update-checkout",
        help="only update the checkout",
        action="store_true",
        dest="update_checkout_only")
    build_actions_group.add_argument(
        "--docs",
        help="build only the documentation",
        action="store_true",
        dest="docs_only")

    parser.add_argument(
        "-j", "--jobs",
        help="the number of parallel build jobs to use",
        type=int,
        dest="build_jobs")
    parser.add_argument(
        "preset_substitutions_raw",
        help="'name=value' pairs that are substituted in the preset",
        nargs="*",
        metavar="SUBSTITUTION")
    parser.add_argument(
        "--expand-build-script-invocation",
        help="Print the expanded build-script invocation generated "
             "by the preset, but do not run the preset",
        action=arguments.action.optional_bool)
    args = parser.parse_args()

    if len(args.preset_file_names) == 0:
        args.preset_file_names = [
            os.path.join(HOME, ".anthem-build-presets"),
            os.path.join(
                ANTHEM_SOURCE_ROOT, ANTHEM_REPO_NAME, "utils",
                "build-presets.ini")
        ]

    if args.show_presets:
        for name in sorted(get_all_preset_names(args.preset_file_names),
                           key=str.lower):
            print(name)
        return 0

    if not args.preset:
        diagnostics.fatal("missing --preset option")

    args.preset_substitutions = {}

    for arg in args.preset_substitutions_raw:
        name, value = arg.split("=", 1)
        args.preset_substitutions[name] = value

    preset_args = get_preset_options(
        args.preset_substitutions, args.preset_file_names, args.preset)

    # Run the new script with the Python executable if the build is done on
    # AppVeyor.
    if 'APPVEYOR' in os.environ.keys() and os.environ['APPVEYOR']:
        build_script_args = [sys.executable]
        build_script_args += [sys.argv[0]]
    else:
        build_script_args = [sys.argv[0]]

    if args.dry_run:
        build_script_args += ["--dry-run"]
    if args.clean:
        build_script_args += ["--clean"]
    elif args.clean_build:
        build_script_args += ["--clean-build"]
    elif args.clean_shared:
        build_script_args += ["--clean-shared"]
    if args.install_only:
        build_script_args += ["--install"]
    elif args.build_only:
        build_script_args += ['--build']
    elif args.test_only:
        build_script_args += ['--run-test']
    elif args.docs_only:
        build_script_args += ['--docs']
    elif args.update_checkout_only:
        build_script_args += ['--update-checkout']
    build_script_args += preset_args
    if args.build_jobs:
        build_script_args += ["--jobs", str(args.build_jobs)]

    diagnostics.note(
        "using preset '" + args.preset + "', which expands to \n\n" +
        shell.quote_command(build_script_args) + "\n")

    if args.expand_build_script_invocation:
        return 0

    shell.call_without_sleeping(build_script_args)
    return 0


def main_normal():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        usage="""
  %(prog)s [-h | --help] [OPTION...]
  %(prog)s --preset=NAME [SUBSTITUTION...]
        """,
        description=program_description,
        epilog=program_epilogue)
    parser.add_argument(
        "-n", "--dry-run",
        help="print the commands that would be executed, but do not execute "
             "them",
        action="store_true",
        default=False)

    ci_group = parser.add_argument_group(title="Continuous integration")
    ci_group.add_argument(
        "--ci",
        help="build in a CI environment",
        action="store_true")
    ci_group.add_argument(
        "--travis",
        help="build in a Travis CI environment",
        action="store_true")
    ci_group.add_argument(
        "--circleci",
        help="build in a CircleCI environment",
        action="store_true")
    ci_group.add_argument(
        "--appveyor",
        help="build in an AppVeyor CI environment",
        action="store_true")

    targets_group = parser.add_argument_group(
        title="Host and cross-compilation targets - These options do not have "
              "any effect yet")
    targets_group.add_argument(
        "--host-target",
        help="The host target. LLVM, Clang, and Unsung Anthem will be built "
             "for this target. The built LLVM and Clang will be used to "
             "compile Unsung Anthem for the cross-compilation targets.",
        default=DeploymentTarget.host_target().name)
    targets_group.add_argument(
        "--cross-compile-hosts",
        help="A space separated list of targets to cross-compile Unsung "
             "Anthem tools for. Can be used multiple times.",
        action=arguments.action.concat, type=arguments.type.shell_split,
        default=[])

    projects_group = parser.add_argument_group(
        title="Options to select projects")
    projects_group.add_argument(
        "-l", "--llvm",
        help="build LLVM and use the built LLVM",
        action="store_true",
        dest="build_llvm")
    projects_group.add_argument(
        "-g", "--gcc",
        help="build GNU Compiler Collection and use the built compiler",
        action="store_true",
        dest="build_gcc")
    projects_group.add_argument(
        "--libc++",
        help="build libc++ and use the built library to build the project",
        action="store_true",
        dest="build_libcxx")
    projects_group.add_argument(
        "--libcxx",
        help="build libc++ and use the built library to build the project",
        action="store_true",
        dest="build_libcxx")
    projects_group.add_argument(
        "--sdl",
        help="build and use SDL (default GLFW)",
        action="store_true")
    projects_group.add_argument(
        "--glfw",
        help="build and use GLFW",
        action="store_true")
    projects_group.add_argument(
        "--build-cmake",
        help="build CMake",
        action="store_true")
    projects_group.add_argument(
        "--build-ninja",
        help="build the Ninja tool",
        action=arguments.action.optional_bool)
    projects_group.add_argument(
        "--build-docs",
        help="build the Unsung Anthem documentation",
        action="store_true",
        dest="build_docs")
    projects_group.add_argument(
        "--build-test",
        help="build the Unsung Anthem tests",
        action="store_true",
        dest="build_test")
    projects_group.add_argument(
        "--build-test-optimized",
        help="build the Unsung Anthem tests with optimization",
        action="store_true",
        dest="build_test_optimized")

    build_actions_group = parser.add_mutually_exclusive_group(required=False)
    build_actions_group.add_argument(
        "--install",
        help="only install the project dependencies",
        action="store_true",
        dest="install_only")
    build_actions_group.add_argument(
        "--build",
        help="build the project without installing the dependencies",
        action="store_true",
        dest="build_only")
    build_actions_group.add_argument(
        "--run-test",
        help="run the tests without installing the dependencies or building "
             "the project",
        action="store_true",
        dest="test_only")
    build_actions_group.add_argument(
        "--update-checkout",
        help="only update the checkout",
        action="store_true",
        dest="update_checkout_only")
    build_actions_group.add_argument(
        "--docs",
        help="build only the documentation",
        action="store_true",
        dest="docs_only")

    extra_actions_group = parser.add_argument_group(
        title="Extra actions to perform before or in addition to building")
    extra_actions_group.add_argument(
        "-c", "--clean",
        help="do a clean build",
        action="store_true")
    extra_actions_group.add_argument(
        "--clean-build",
        help="do a clean build but do not redownload the dependencies",
        action="store_true")
    extra_actions_group.add_argument(
        "--clean-shared",
        help="delete only the shared build",
        action="store_true")

    parser.add_argument(
        "--stdlib",
        help="build using the specified C++ standard library implementation",
        dest="stdlib")

    parser.add_argument(
        "--use-experimental-headers",
        help="use the experimental headers instead of the ones in the current "
             "C++ standard",
        action="store_true",
        dest="cxx_experimental")
    parser.add_argument(
        "--experimental-headers",
        help="use the experimental headers instead of the ones in the current "
             "C++ standard",
        action="store_true",
        dest="cxx_experimental")

    parser.add_argument(
        "--enable-gcov",
        help="use gcov and lcov to generate code coverage information",
        action="store_true",
        dest="enable_gcov")

    cpp_version_group = parser.add_mutually_exclusive_group(required=False)
    cpp_version_group.add_argument(
        "--std",
        help="build using the specified C++ standard version",
        default="c++14",
        dest="std")
    cpp_version_group.add_argument(
        "--c++latest",
        help="build using the latest features of the C++ standard version and"
             "its drafts (default is C++14)",
        action="store_const",
        const="c++latest",
        dest="std")
    cpp_version_group.add_argument(
        "--c++2a",
        help="build using the next C++ standard draft (default is C++14)",
        action="store_const",
        const="c++2a",
        dest="std")
    cpp_version_group.add_argument(
        "--c++17",
        help="build using the C++17 standard version (default is C++14)",
        action="store_const",
        const="c++17",
        dest="std")
    cpp_version_group.add_argument(
        "--c++14",
        help="build using the C++14 standard version (default)",
        action="store_const",
        const="c++14",
        dest="std")

    build_variant_group = parser.add_mutually_exclusive_group(required=False)
    build_variant_group.add_argument(
        "-d", "--debug",
        help="build the Debug variant of everything (default)",
        action="store_const",
        const="Debug",
        dest="build_variant")
    build_variant_group.add_argument(
        "-r", "--release-debuginfo",
        help="build the RelWithDebInfo variant of everything (default is "
             "Debug)",
        action="store_const",
        const="RelWithDebInfo",
        dest="build_variant")
    build_variant_group.add_argument(
        "-R", "--release",
        help="build the Release variant of everything (default is Debug)",
        action="store_const",
        const="Release",
        dest="build_variant")

    build_variant_override_group = parser.add_argument_group(
        title="Override build variant for a specific project")
    build_variant_override_group.add_argument(
        "--debug-llvm",
        help="build the Debug variant of LLVM",
        action="store_const",
        const="Debug",
        dest="llvm_build_variant")
    build_variant_override_group.add_argument(
        "--debug-libcxx",
        help="build the Debug variant of libc++. This has an effect only if "
             "LLVM is not built",
        action="store_const",
        const="Debug",
        dest="libcxx_build_variant")
    build_variant_override_group.add_argument(
        "--debug-anthem",
        help="build the Debug variant of Unsung Anthem",
        action="store_const",
        const="Debug",
        dest="anthem_build_variant")
    build_variant_override_group.add_argument(
        "--debug-sdl",
        help="build the Debug variant of SDL",
        action="store_const",
        const="Debug",
        dest="sdl_build_variant")
    build_variant_override_group.add_argument(
        "--debug-glfw",
        help="build the Debug variant of GLFW",
        action="store_const",
        const="Debug",
        dest="glfw_build_variant")

    assertions_group = parser.add_mutually_exclusive_group(required=False)
    assertions_group.add_argument(
        "--assertions",
        help="enable assertions in all projects",
        action="store_const",
        const=True,
        dest="assertions")
    assertions_group.add_argument(
        "--no-assertions",
        help="disable assertions in all projects",
        action="store_const",
        const=False,
        dest="assertions")

    assertions_override_group = parser.add_argument_group(
        title="Control assertions in a specific project")
    assertions_override_group.add_argument(
        "--llvm-assertions",
        help="enable assertions in LLVM",
        action="store_const",
        const=True,
        dest="llvm_assertions")
    assertions_override_group.add_argument(
        "--no-llvm-assertions",
        help="disable assertions in LLVM",
        action="store_const",
        const=False,
        dest="llvm_assertions")
    assertions_override_group.add_argument(
        "--libcxx-assertions",
        help="enable assertions in libc++",
        action="store_const",
        const=True,
        dest="libcxx_assertions")
    assertions_override_group.add_argument(
        "--no-libcxx-assertions",
        help="disable assertions in libc++",
        action="store_const",
        const=False,
        dest="libcxx_assertions")
    assertions_override_group.add_argument(
        "--anthem-assertions",
        help="enable assertions in Unsung Anthem",
        action="store_const",
        const=True,
        dest="anthem_assertions")
    assertions_override_group.add_argument(
        "--no-anthem-assertions",
        help="disable assertions in Unsung Anthem",
        action="store_const",
        const=False,
        dest="anthem_assertions")

    # FIXME: This should be one option using choices=[...]
    cmake_generator_group = parser.add_argument_group(
        title="Select the CMake generator")
    cmake_generator_group.add_argument(
        "-x", "--xcode",
        help="use CMake's Xcode generator (default is Ninja)",
        action="store_const",
        const="Xcode",
        dest="cmake_generator")
    cmake_generator_group.add_argument(
        "-m", "--make",
        help="use CMake's Makefile generator (default is Ninja)",
        action="store_const",
        const="Unix Makefiles",
        dest="cmake_generator")
    cmake_generator_group.add_argument(
        "--visual-studio-14",
        help="use CMake's Visual Studio 2015 generator (default is Ninja)",
        action="store_const",
        const="Visual Studio 14 2015",
        dest="cmake_generator")
    cmake_generator_group.add_argument(
        "--visual-studio-2015",
        help="use CMake's Visual Studio 2015 generator (default is Ninja)",
        action="store_const",
        const="Visual Studio 14 2015",
        dest="cmake_generator")
    cmake_generator_group.add_argument(
        "--visual-studio-15",
        help="use CMake's Visual Studio 2017 generator (default is Ninja)",
        action="store_const",
        const="Visual Studio 15 2017",
        dest="cmake_generator")
    cmake_generator_group.add_argument(
        "--visual-studio-2017",
        help="use CMake's Visual Studio 2017 generator (default is Ninja)",
        action="store_const",
        const="Visual Studio 15 2017",
        dest="cmake_generator")
    cmake_generator_group.add_argument(
        "-e", "--eclipse",
        help="use CMake's Eclipse generator (default is Ninja)",
        action="store_const",
        const="Eclipse CDT4 - Ninja",
        dest="cmake_generator")

    run_tests_group = parser.add_argument_group(
        title="Run tests")

    # NOTE: We cannot merge -t and --test, because nargs='?' makes
    #       `-ti` to be treated as `-t=i`.
    run_tests_group.add_argument(
        "-t",
        help="test Unsung Anthem after building (implies --build-test)",
        action="store_const",
        const=True,
        dest="test")
    run_tests_group.add_argument(
        "--test",
        help="test Unsung Anthem after building (implies --build-test)",
        action=arguments.action.optional_bool)
    run_tests_group.add_argument(
        "-o",
        help="run the test suite in optimized mode too (implies --test and "
             "--build-test-optimized)",
        action="store_const",
        const=True,
        dest="test_optimized")
    run_tests_group.add_argument(
        "--test-optimized",
        help="run the test suite in optimized mode too (implies --test and "
             "--build-test-optimized)",
        action=arguments.action.optional_bool)

    run_build_group = parser.add_argument_group(
        title="Run build")
    run_build_group.add_argument(
        "-S", "--skip-build",
        help="generate build directory only without building",
        action="store_true")

    run_build_group.add_argument(
        "--clion",
        help="install the dependencies and generate the CMake command for "
             "setting up an CLion environment",
        action="store_true")

    run_build_group.add_argument(
        "--skip-build-anthem",
        help="skip building Unsung Anthem",
        action=arguments.action.optional_bool)

    checkout_group = parser.add_argument_group(title="Update checkout")
    checkout_group.add_argument(
        "--skip-repository",
        metavar="DIRECTORY",
        default=[],
        help="skip the specified repository. To skip a specific LLVM project, "
             "add the prefix llvm- to the name of the project.",
        dest='skip_repository_list',
        action="append")

    version_group = parser.add_argument_group(title="Dependency and project "
                                                    "version information")
    version_group.add_argument(
        "--anthem-version",
        metavar="MAJOR.MINOR.PATCH",
        default='default',
        help="the Unsung Anthem version")
    version_group.add_argument(
        "--llvm-version",
        metavar="MAJOR.MINOR.PATCH",
        default='default',
        help="the LLVM version")
    version_group.add_argument(
        "--gcc-version",
        metavar="MAJOR.MINOR.PATCH",
        default='default',
        help="the GNU Compiler Collection version")
    version_group.add_argument(
        "--cmake-major-version",
        metavar="MAJOR",
        default='default',
        help="the CMake major version")
    version_group.add_argument(
        "--cmake-minor-version",
        metavar="MINOR",
        default='default',
        help="the CMake minor version")
    version_group.add_argument(
        "--cmake-patch-version",
        metavar="PATCH",
        default='default',
        help="the CMake patch version")
    version_group.add_argument(
        "--cmake-minor-patch-version",
        metavar="MINOR_PATCH",
        default='default',
        help="the CMake minor patch version")
    version_group.add_argument(
        "--cmake-version",
        metavar="MAJOR.MINOR.PATCH(.MINOR_PATCH)",
        default='default',
        help="the CMake version. Overrides the major, minor, patch, and minor "
             "patch settings if set")
    version_group.add_argument(
        "--ninja-version",
        metavar="MAJOR.MINOR.PATCH",
        default='default',
        help="the Ninja version")
    version_group.add_argument(
        "--catch-version",
        metavar="MAJOR.MINOR.PATCH",
        default='default',
        help="the Catch version")
    version_group.add_argument(
        "--sdl-version",
        metavar="MAJOR.MINOR.PATCH",
        default='default',
        help="the SDL version")
    version_group.add_argument(
        "--glfw-version",
        metavar="MAJOR.MINOR.PATCH",
        default='default',
        help="the GLFW version")
    version_group.add_argument(
        "--spdlog-version",
        metavar="MAJOR.MINOR.PATCH",
        default='default',
        help="the spdlog version")
    version_group.add_argument(
        "--cat-version",
        metavar="MAJOR.MINOR",
        default='default',
        help="the cat library version")

    parser.add_argument(
        "--build-config",
        default=os.path.join(SCRIPT_DIR, "anthem-config.json"),
        metavar='PATH',
        help="the build configuration file to use")

    parser.add_argument(
        '--disable-manual-tar',
        help='disable calling the "tar" executable on some archives on older '
             'Python versions',
        action='store_true')

    parser.add_argument(
        '--disable-xcodebuild',
        help='disable using xcodebuild to build the projects when using the '
             'Xcode CMake generator',
        action='store_true')

    parser.add_argument(
        "--build-subdir",
        help="name of the directory under $ANTHEM_BUILD_ROOT where the build "
             "products will be placed",
        metavar="PATH")
    parser.add_argument(
        "--tool-build-subdir",
        help="name of the directory under $ANTHEM_BUILD_ROOT where the shared "
             "build products will be placed. Has an effect only if the shared "
             "tools are not disabled",
        metavar="PATH")
    parser.add_argument(
        "--install-prefix",
        help="The installation prefix. This is where built Unsung Anthem "
             "products (like bin, lib, and include) will be installed.",
        metavar="PATH")

    parser.add_argument(
        "-j", "--jobs",
        help="the number of parallel build jobs to use",
        type=int,
        dest="build_jobs",
        default=multiprocessing.cpu_count())

    parser.add_argument(
        "--darwin-xcrun-toolchain",
        help="the name of the toolchain to use on Darwin",
        default="default")
    parser.add_argument(
        "--cmake",
        help="the path to a CMake executable that will be used to build "
             "Unsung Anthem",
        type=arguments.type.executable,
        metavar="PATH")
    parser.add_argument(
        "--git",
        help="the path to a git executable that will be used to clone "
             "possible git projects",
        type=arguments.type.executable,
        metavar="PATH")

    parser.add_argument(
        "--host-cc",
        help="the absolute path to CC, the C compiler for the host platform. "
             "Default is auto detected.",
        type=arguments.type.executable,
        metavar="PATH")
    parser.add_argument(
        "--host-cxx",
        help="the absolute path to CXX, the C++ compiler for the host "
             "platform. Default is auto detected.",
        type=arguments.type.executable,
        metavar="PATH")
    parser.add_argument(
        "--xcodebuild",
        help="the absolute path to xcodebuild. Default is auto detected.",
        type=arguments.type.executable,
        metavar="PATH")
    parser.add_argument(
        "--msbuild",
        help="the absolute path to MSBuild, the Microsoft Visual Studio "
             "compiler for the host platform. Default is auto detected.",
        type=arguments.type.executable,
        metavar="PATH")
    parser.add_argument(
        "--main-tool",
        help="the name of the main tool to be looked by the script. The "
             "default is llvm.",
        metavar="NAME",
        default='llvm')
    parser.add_argument(
        "--main-tool-version",
        help="the version of the main tool which will be used in the lookup "
             "of the tool",
        metavar="VERSION",
        default='default')
    parser.add_argument(
        '--disable-shared-tools',
        help='disallow sharing tools and dependencies between Unsung Anthem '
             'versions if the versions are the same',
        action='store_true')

    parser.add_argument(
        "--gcc-mirror",
        help="the mirror from which GCC is downloaded if it is built",
        metavar="URL",
        default='default')

    msbuild_group = parser.add_argument_group(title="MSBuild options")
    msbuild_group.add_argument(
        "--msbuild-logger",
        help="the absolute path to MSBuild logger",
        metavar="PATH")

    parser.add_argument(
        "--executable-name",
        help="the name of the Unsung Anthem executable",
        metavar="NAME")
    parser.add_argument(
        "--test-executable-name",
        help="the name of the Unsung Anthem test executable",
        metavar="NAME")

    parser.add_argument(
        "--darwin-deployment-version",
        help="minimum deployment target version for macOS",
        metavar="MAJOR.MINOR",
        default="10.9")

    parser.add_argument(
        "--extra-cmake-options",
        help="Pass through extra options to CMake in the form of comma "
             "separated options '-DCMAKE_VAR1=YES,-DCMAKE_VAR2=/tmp'. Can be "
             "called multiple times to add multiple such options.",
        action=arguments.action.concat,
        type=arguments.type.shell_split,
        default=[])

    parser.add_argument(
        "--build-args",
        help="arguments to the build tool. This would be prepended to the "
             "default argument that is '-j8' when CMake generator is "
             "\"Ninja\".",
        type=arguments.type.shell_split,
        default=[])

    args = migration.parse_args(parser, sys.argv[1:])

    # Set the dry run setting of the shell utilities.
    shell.dry_run = args.dry_run

    diagnostics.note('The main tool is set to ' + str(args.main_tool))
    diagnostics.note('The main tool version is set to '
                     + str(args.main_tool_version))

    # LLVM and Clang are synonyms as main tools.
    if args.main_tool == 'clang':
        args.main_tool = 'llvm'

    # Apply the default continuous integration arguments.
    apply_default_ci_arguments(args=args)

    # Apply the default values of the arguments to the args namespace.
    apply_default_arguments(args=args)

    # Apply the default C++ standard-related arguments.
    apply_default_cxx_std_arguments(args=args)

    # Create a dictionary for saving the version also by simple strings.
    args.version_info = {}

    # Apply the default versions of the dependencies.
    apply_default_version_arguments(args=args)

    # Apply the default paths and filename after the default versions as the
    # version information is required in the filenames.
    apply_default_file_arguments(args=args)

    # Check the validity of the arguments.
    validate_arguments(args=args)

    # Set the C++ standard version to c++latest if it is set to latest so the
    # script does not have to deal with two different values for the same
    # functionality.
    if args.std == 'latest':
        args.std = 'c++latest'

    # Create the workspace object containing the build-related directories.
    workspace = Workspace(args=args,
                          source_root=ANTHEM_SOURCE_ROOT,
                          build_root=os.path.join(ANTHEM_BUILD_ROOT,
                                                  args.build_subdir),
                          tool_build_root=os.path.join(ANTHEM_BUILD_ROOT,
                                                       args.tool_build_subdir),
                          install_root=os.path.join(ANTHEM_BUILD_ROOT,
                                                    args.install_prefix))

    # Clean build directory if requested.
    if args.clean:
        clean_delay()

    # Clean build directory if requested.
    if args.clean_build:
        shell.rmtree(workspace.build_root)

    if args.share_tools and args.clean_shared:
        shell.rmtree(workspace.tool_build_root, ignore_errors=True)

    # Create the build directory.
    shell.makedirs(workspace.build_root)
    shell.makedirs(workspace.tool_build_root)

    # Create the install directory.
    shell.makedirs(workspace.install_root)

    # Register the tools to the toolchain.
    register_tools(args=args)

    # Prepare and validate the toolchain.
    toolchain = host_toolchain(xcrun_toolchain=args.darwin_xcrun_toolchain)
    os.environ['TOOLCHAINS'] = args.darwin_xcrun_toolchain

    if args.host_cc is not None:
        toolchain.cc = args.host_cc

    if args.host_cxx is not None:
        toolchain.cxx = args.host_cxx

    if args.xcodebuild is not None:
        toolchain.xcodebuild = args.xcodebuild

    if args.msbuild is not None:
        toolchain.msbuild = args.msbuild

    if args.cmake is not None:
        toolchain.cmake = args.cmake

    if args.git is not None:
        toolchain.git = args.git

    # Apply the default checkout skipping options after the script knows which
    # tools are on the system already.
    apply_default_checkout_skip_arguments(args=args, toolchain=toolchain)

    # Update the checkout.
    if not args.build_only and not args.test_only and not args.docs_only:
        checkout.update(args, toolchain)

    # Do not continue further if the script should only update the checkout.
    if args.update_checkout_only:
        return 0

    # Parse the versions from git if any git versions were used.
    parse_git_versions(args)

    # Build ninja if required, which will update the toolchain.
    if ((args.build_ninja
         or ((args.cmake_generator == 'Ninja'
              or args.cmake_generator == 'Xcode')
             and toolchain.ninja is None)) and not args.test_only
            and not args.docs_only):
        ninja.build(args=args, toolchain=toolchain, workspace=workspace)

    # Build CMake.
    if ((args.build_cmake or toolchain.cmake is None) and not args.test_only
            and not args.docs_only):
        cmake.build(args=args, toolchain=toolchain, workspace=workspace)

    # Build LLVM, Clang, and libc++.
    if (args.build_llvm or args.build_libcxx) \
            and not args.test_only and not args.docs_only:
        llvm.build(args=args, toolchain=toolchain, workspace=workspace)

    # Build GCC.
    if args.build_gcc and not args.test_only and not args.docs_only:
        gcc.build(args=args, toolchain=toolchain, workspace=workspace)

    # If the main tool for build is MSBuild and CC and CXX are set to None,
    # set them as the MSBuild executable.
    if args.main_tool == 'msbuild':
        if toolchain.cc is None:
            toolchain.cc = toolchain.msbuild
        if toolchain.cxx is None:
            toolchain.cxx = toolchain.msbuild

    diagnostics.note('The host C compiler is set to ' + str(toolchain.cc))
    diagnostics.note('The host C++ compiler is set to ' + str(toolchain.cxx))
    diagnostics.note('MSBuild is set to ' + str(toolchain.msbuild))
    diagnostics.note('Ninja is set to ' + str(toolchain.ninja))
    diagnostics.note('CMake is set to ' + str(toolchain.cmake))
    diagnostics.note('git is set to ' + str(toolchain.git))

    if args.cmake_generator == 'Xcode' and not args.disable_xcodebuild:
        diagnostics.note('xcodebuild is set to ' + str(toolchain.xcodebuild))

    diagnostics.note('The C++ standard version is set to ' + args.std)

    if args.stdlib_set:
        diagnostics.note('The C++ standard library is set to ' + args.stdlib)

    # Tell the user that this set-up will not build the final product but
    # rather only set it up for CLion.
    if args.clion:
        diagnostics.note('The CLion set-up is enabled and, thus, the final '
                         'Unsung Anthem executable will not be built')

    if not args.build_only and not args.test_only and not args.docs_only:
        if args.sdl:
            # Build SDL.
            sdl.build(args=args, toolchain=toolchain, workspace=workspace)
        elif args.glfw:
            # Build GLFW.
            glfw.build(args=args, toolchain=toolchain, workspace=workspace)

    # Copy the files of the Unsung Anthem dependencies to the correct
    # directories.
    if not args.build_only and not args.test_only and not args.docs_only:
        cat.build(args=args, toolchain=toolchain, workspace=workspace)
        spdlog.build(args=args, toolchain=toolchain, workspace=workspace)

    # Copy the files of the Unsung Anthem test dependencies to the correct
    # directories.
    if args.clion or (args.build_test
                      and not args.build_only
                      and not args.test_only
                      and not args.docs_only):
        catch.build(args=args, toolchain=toolchain, workspace=workspace)

    # Build Unsung Anthem.
    if not args.install_only and not args.test_only and not args.docs_only:
        anthem.build(args=args, toolchain=toolchain, workspace=workspace)

    # Build the Unsung Anthem tests.
    if args.build_test and not args.install_only and not args.test_only \
            and not args.docs_only:
        anthem.build(args=args,
                     toolchain=toolchain,
                     workspace=workspace,
                     tests=True)

    # Run the tests.
    if (args.test
            or args.test_only) \
            and not args.build_only and not args.install_only \
            and not args.docs_only:
        if args.cmake_generator == "Xcode":
            with shell.pushd(workspace.anthem_build_dir(args.host_target,
                                                        'anthem-test')):
                shell.call_without_sleeping([os.path.join(
                    workspace.anthem_build_dir(args.host_target, 'anthem-test'),
                    args.anthem_build_variant,
                    args.test_executable_name)])
        else:
            with shell.pushd(workspace.anthem_build_dir(args.host_target,
                                                        'anthem-test')):
                shell.call_without_sleeping([os.path.join(
                    workspace.anthem_build_dir(args.host_target, 'anthem-test'),
                    args.test_executable_name)])

    # Build the documentation.
    if args.build_docs or args.docs_only:
        docs.build(args=args, toolchain=toolchain, workspace=workspace)

    return 0


def main():
    """
    The entry point function of the script.

    :return:
    """
    # First check if the root directory environment variable of the build is
    # set.
    if not ANTHEM_SOURCE_ROOT:
        diagnostics.fatal("could not infer source root directory (forgot to "
                          "set $ANTHEM_SOURCE_ROOT environment variable?)")

    # Then check if the root directory of the build exists and is a directory.
    if not os.path.isdir(ANTHEM_SOURCE_ROOT):
        diagnostics.fatal("source root directory \'"
                          + ANTHEM_SOURCE_ROOT
                          + "\' does not exist (forgot to set "
                            "$ANTHEM_SOURCE_ROOT environment variable?)")

    # Determine if the script is invoked in the preset mode and dispatch
    # accordingly.
    if any([(opt.startswith("--preset") or opt == "--show-presets")
            for opt in sys.argv[1:]]):
        return main_preset()
    else:
        return main_normal()


if __name__ == '__main__':
    sys.exit(main())
