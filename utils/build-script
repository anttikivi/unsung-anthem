#!/usr/bin/env python

#===----------------------------- build-script ---------------*- python -*-===#
#
#                         Obliging Ode & Unsung Anthem
#
# This source file is part of the Obliging Ode and Unsung Anthem open source
# projects.
#
# Copyright (c) 2018 Venturesome Stone
# Licensed under GNU Affero General Public License v3.0


"""
Use this tool to build, test, and prepare binary distribution archives of
Obliging Ode and Unsung Anthem.

Builds Obliging Ode and Unsung Anthem and their dependencies, incrementally,
optionally testing Obliging Ode and Unsung Anthem thereafter. Different build
configurations are maintained in parallel.
"""


from __future__ import print_function

import json
import os
import pipes
import platform
import shutil
import subprocess
import sys

from contextlib import contextmanager

import requests


ODE_BUILD_VERSION = "0.3.0-dev.6"
ODE_BUILD_KEY = "ode-build"


REPO_OWNER = "venturesomestone"
REPO_NAME = ODE_BUILD_KEY


#===------------------------------------------------------------------------===#
#==- Shell ------------------------------------------------------------------==#
#===------------------------------------------------------------------------===#


DEVNULL = getattr(subprocess, "DEVNULL", subprocess.PIPE)


def _quote(arg):
    return pipes.quote(str(arg))


def quote_command(args):
    """Quote the command for passing to a shell."""
    return " ".join([_quote(a) for a in args])


def _echo_command(command, env=None, prompt="+ "):
    output = []
    if env is not None:
        output += ["env"] + [_quote("%s=%s" % (k, v))
                             for (k, v) in sorted(env.items())]
    output += [_quote(arg) for arg in command]
    file = sys.stderr
    # if dry_run:
    #     file = sys.stdout
    print(prompt + " ".join(output), file=file)
    file.flush()


def call(command, stderr=None, env=None):
    """Execute the given command."""
    _echo_command(command, env=env)
    _env = None
    if env is not None:
        _env = dict(os.environ)
        _env.update(env)
    try:
        subprocess.check_call(command, env=_env, stderr=stderr)
        return 0
    except subprocess.CalledProcessError as e:
        SystemExit(
            "Command terminated with a non-zero exit status {}, "
            "aborting".format(e.returncode))
        return 3
    except OSError as e:
        SystemExit("Could not execute '{}': {}".format(
            quote_command(command), e.strerror))
        return 3


def capture(
        command, stderr=None, env=None, optional=False,
        allow_non_zero_exit=False):
    """Execute the given command and return the standard output."""
    _echo_command(command, env=env)
    _env = None
    if env is not None:
        _env = dict(os.environ)
        _env.update(env)
    try:
        out = subprocess.check_output(command, env=_env, stderr=stderr)
        # Coerce to `str` hack. not py3 `byte`, not py2 `unicode`.
        return str(out.decode())
    except subprocess.CalledProcessError as e:
        if allow_non_zero_exit:
            return e.output
        if optional:
            return None
        SystemExit(
            "Command terminated with a non-zero exit status {}, "
            "aborting".format(e.returncode))
        return 3
    except OSError as e:
        if optional:
            return None
        SystemExit("Could not execute '{}': {}".format(
            quote_command(command), e.strerror))
        return 3


def makedirs(path):
    _echo_command(["mkdir", "-p", path])
    if not os.path.isdir(path):
        os.makedirs(path)


def rmtree(path):
    _echo_command(["rm", "-rf", path])
    if os.path.exists(path):
        shutil.rmtree(path)


def copytree(src, dest):
    _echo_command(["cp", "-r", src, dest])
    # A workaround
    if os.path.isdir(dest):  # and data.build.ci:
        for item in os.listdir(src):
            s = os.path.join(src, item)
            d = os.path.join(dest, item)
            if os.path.isdir(s):
                shutil.copytree(s, d)  # , symlinks, ignore)
            else:
                shutil.copy2(s, d)
    else:
        shutil.copytree(src, dest)


@contextmanager
def pushd(path):
    old_dir = os.getcwd()
    _echo_command(["pushd", path])
    os.chdir(path)
    yield
    _echo_command(["popd"])
    os.chdir(old_dir)


def which(cmd):
    if sys.version_info[0] >= 3:
        import shutil
        return shutil.which(cmd)
    out = capture(["which", cmd], optional=True)
    return out.rstrip() if out is not None else None


def where(cmd):
    if sys.version_info[0] >= 3:
        import shutil
        return shutil.which(cmd)
    out = capture(["where.exe", cmd], optional=True)
    return out.rstrip() if out is not None else None


def xcrun_find(cmd):
    command = [
        "xcrun", "--find", cmd, "--sdk", "macosx", "--toolchain", "default"]
    out = capture(
        command, stderr=DEVNULL, optional=True)
    if out is None:
        return None
    return out.rstrip()


def windows_find(cmd):
    found = where(cmd)
    if found is not None:
        return found.replace("/c/", "C:\\").replace("/", "\\")
    return found


def find_tool(tool):
    sys = platform.system()
    if sys == "Darwin":
        return xcrun_find(tool)
    elif sys == "Linux":
        return which(tool)
    elif sys == "FreeBSD":
        return which(tool)
    elif sys.startswith("CYGWIN"):
        return which(tool)
    elif sys == "Windows":
        return windows_find(tool)
    raise NotImplementedError(
        "The platform '{}' does not have a defined toolchain".format(sys))


def caffeinate(command, env=None):
    """
    Execute a command during which system sleep is disabled.
    By default, this ignores the state of the 'shell.dry_run' flag.
    """
    # Disable system sleep, if possible.
    if platform.system() == "Darwin":
        # Don't mutate the caller's copy of the arguments.
        command = ["caffeinate"] + list(command)
    call(command, env=env)


#===------------------------------------------------------------------------===#
#==- Paths ------------------------------------------------------------------==#
#===------------------------------------------------------------------------===#


def _anthem_path():
    # Get the parent directory of this file for checking if this file is
    # located in an Unsung Anthem checkout.
    #
    # $ANTHEM_SOURCE_ROOT/unsung-anthem/utils/build-script
    utils_path = os.path.dirname(__file__)
    # Split the path as the first part of the 'utils_path' is presumably the
    # Unsung Anthem checkout.
    anthem_path, parent_dirname = os.path.split(utils_path)
    if parent_dirname != "utils":
        return ""
    # The checkout has to have CMake Listfile.
    if not os.path.exists(os.path.join(anthem_path, "CMakeLists.txt")):
        return ""
    return anthem_path


def _get_default_source_root():
    return os.path.dirname(_anthem_path())


# $ANTHEM_SOURCE_ROOT is resolved from the path of this file if the environment
# variable is not set.
ANTHEM_SOURCE_ROOT = os.environ.get(
    "ANTHEM_SOURCE_ROOT", _get_default_source_root())


# $ODE_BUILD_ROOT is resolved from $ANTHEM_SOURCE_ROOT if the
# environment variable is not set.
# TODO
ODE_BUILD_ROOT = os.environ.get(
    "ODE_BUILD_ROOT", os.path.join(ANTHEM_SOURCE_ROOT, "script"))


CHECKOUT_FILE = os.path.join(ANTHEM_SOURCE_ROOT, "checkout", "ode-build-data")


def _get_default_anthem_repo_name():
    # Split the path of the checkout directory as the latter part of it is the
    # filename of the checkout directory.
    _, anthem_repo_name = os.path.split(_anthem_path())
    return anthem_repo_name


# $ANTHEM_REPO_NAME is resolved from the path of this file if the environment
# variable is not set.
ANTHEM_REPO_NAME = os.environ.get(
    "ANTHEM_REPO_NAME", _get_default_anthem_repo_name())


SCRIPT_DIR = os.path.join(ANTHEM_SOURCE_ROOT, ANTHEM_REPO_NAME, "utils")


SOURCE_DIR = os.path.join("checkout", "ode-build", ODE_BUILD_VERSION, "src")


TEMP_DIR = os.path.join("checkout", "ode-build", "temp")


#===------------------------------------------------------------------------===#
#==- Github -----------------------------------------------------------------==#
#===------------------------------------------------------------------------===#


def _auth_token():
    ret_auth_token = None
    t_file = os.path.join(ANTHEM_SOURCE_ROOT, ANTHEM_REPO_NAME, "token")
    if os.path.exists(t_file):
        with open(t_file) as token_file:
            ret_auth_token = str(token_file.read())
    if ret_auth_token:
        return ret_auth_token
    elif "ODE_OAUTH" in os.environ:
        return str(os.environ["ODE_OAUTH"])
    elif "ANTHEM_OAUTH" in os.environ:
        return str(os.environ["ANTHEM_OAUTH"])


GITHUB_API_V4_ENDPOINT = "https://api.github.com/graphql"


def call_query(file_name, replacements=None):
    """Calls the given GraphQL query."""
    with open(os.path.join(SCRIPT_DIR, file_name)) as query_file:
        raw_query = str(query_file.read())
    if replacements:
        for k, v in replacements.items():
            raw_query = raw_query.replace(k, v)
    query = json.dumps({"query": raw_query})
    response = requests.post(
        url=GITHUB_API_V4_ENDPOINT,
        data=query,
        headers={
            "User-Agent": "venturesomestone", "Accept": "application/json",
            "Authorization": "bearer {}".format(_auth_token())
        })
    return response.json()["data"]


def find_release_node(json_data, let_use_fallback=False):
    """Finds the requested release node from the GitHub API JSON data."""
    release_edges = json_data["repository"]["releases"]["edges"]
    ret_node = None
    gh_version = ODE_BUILD_VERSION
    for edge in release_edges:
        node = edge["node"]
        if node is None or node["name"] == "":
            continue
        if node["name"] == gh_version:
            ret_node = node

    if not ret_node and let_use_fallback:
        return release_edges[0]["node"]

    return ret_node


def find_release_node_by_tag(json_data):
    """
    Finds the requested release node from the GitHub API JSON data by the tag
    name."""
    release_edges = json_data["repository"]["releases"]["edges"]
    ret_node = None
    gh_version = ODE_BUILD_VERSION
    for edge in release_edges:
        node = edge["node"]
        if node is None or node["name"] == "":
            continue
        tag_name = node["tag"]["name"]
        if tag_name == gh_version:
            ret_node = node
    return ret_node


def checkout_tag_windows(tag_ref_name):
    """Checkout a tag."""
    with pushd(SOURCE_DIR):
        call([
            find_tool("git"), "checkout", "tags/{}".format(tag_ref_name), "-b",
            "{}_anthem_branch".format(tag_ref_name)])


def checkout_tag(tag_ref_name):
    """Checkout a tag."""
    key = ODE_BUILD_KEY
    with pushd(os.path.join(TEMP_DIR, key)):
        call([
            find_tool("git"), "checkout", "tags/{}".format(tag_ref_name), "-b",
            "{}_anthem_branch".format(tag_ref_name)])


TAG_QUERY_GRAPHQL = "github_tag.graphql"


def download_v4():
    """Download a tag from GitHub."""
    response_json_data = call_query(TAG_QUERY_GRAPHQL, {
        "{REPOSITORY_OWNER}": REPO_OWNER,
        "{REPOSITORY_NAME}": REPO_NAME
    })

    if platform.system() == "Windows":
        head, tail = os.path.split(SOURCE_DIR)
        with pushd(head):
            call([find_tool("git"), "clone", "{}.git".format(
                response_json_data["repository"]["url"]), tail])
    else:
        with pushd(TEMP_DIR):
            call([find_tool("git"), "clone", "{}.git".format(
                response_json_data["repository"]["url"])])
    release_node = find_release_node(response_json_data)

    if not release_node:
        release_node = find_release_node_by_tag(response_json_data)

    tag_ref_name = ODE_BUILD_VERSION if not release_node \
        else release_node["tag"]["name"]

    if platform.system() == "Windows":
        checkout_tag_windows(tag_ref_name)
    else:
        checkout_tag(tag_ref_name)


def get():
    rmtree(SOURCE_DIR)
    rmtree(TEMP_DIR)
    makedirs(SOURCE_DIR)
    makedirs(TEMP_DIR)
    download_v4()
    if platform.system() != "Windows":
        source_dir = SOURCE_DIR
        version_dir = os.path.dirname(source_dir)
        rmtree(source_dir)
        rmtree(version_dir)
        copytree(os.path.join(TEMP_DIR, ODE_BUILD_KEY), SOURCE_DIR)
    rmtree(TEMP_DIR)


def write_version_file(versions):
    """Writes the version information to the versions file."""
    with open(CHECKOUT_FILE, "w") as outfile:
        json.dump(versions, outfile)


def checkout():
    if os.path.isfile(CHECKOUT_FILE):
        with open(CHECKOUT_FILE) as json_file:
            versions = json.load(json_file)
    else:
        versions = {}
    key = ODE_BUILD_KEY
    if key in versions and ODE_BUILD_VERSION == versions[key]["version"]:
        print("{} should not be re-downloaded, skipping".format(key))
        return 0
    get()
    info = {"version": ODE_BUILD_VERSION, "targets": "src"}
    versions[key] = info
    write_version_file(versions)
    rmtree(ODE_BUILD_ROOT)
    copytree(os.path.join(SOURCE_DIR, "utils"), ODE_BUILD_ROOT)


#===------------------------------------------------------------------------===#
#==- Main -------------------------------------------------------------------==#
#===------------------------------------------------------------------------===#


def main():
    """
    The entry point function of the script.
    """
    checkout()
    if "CI" in os.environ and os.environ["CI"]:
        return 0
    else:
        args = []
        if platform.system() == "Windows":
            args += [sys.executable]
        args += [os.path.join(ODE_BUILD_ROOT, "build-script")]
        args += sys.argv[1:]
        return caffeinate(args)


if __name__ == "__main__":
    sys.exit(main())
