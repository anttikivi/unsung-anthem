#!/usr/bin/env python

#===----------------------------- build-script ---------------*- python -*-===#
#
#                         Obliging Ode & Unsung Anthem
#
# This source file is part of the Obliging Ode and Unsung Anthem open source
# projects.
#
# Copyright (c) 2018 Venturesome Stone
# Licensed under GNU Affero General Public License v3.0


"""
Use this tool to build, test, and prepare binary distribution archives of
Obliging Ode and Unsung Anthem.

Builds Obliging Ode and Unsung Anthem and their dependencies, incrementally,
optionally testing Obliging Ode and Unsung Anthem thereafter. Different build
configurations are maintained in parallel.
"""

from __future__ import print_function

import argparse
import os
import platform
import sys
import time

from build_utils import diagnostics, reflection, shell, workspace

from build_utils.mapping import Mapping

from build_utils.presets import get_all_preset_names, get_preset_options

from build_utils.toolchain import host_toolchain, set_arguments_to_toolchain

from checkout import checkout

from products import anthem, common, ode

from script_support import defaults, data, driver_arguments

from script_support.defaults import PRODUCT_CONFIG

from script_support.variables import HOME, ANTHEM_REPO_NAME, \
    ANTHEM_SOURCE_ROOT, ANTHEM_BUILD_ROOT, ANTHEM_CHECKOUT_ROOT


def _exit_rejecting_arguments(message, parser=None):
    print(message, file=sys.stderr)
    if parser:
        parser.print_usage(sys.stderr)
    sys.exit(2)  # 2 is the same as 'argparse' error exit code.


def _validate_arguments(args):
    if not args.build_ode and not args.build_anthem:
        _exit_rejecting_arguments(
            "Both the build of Obliging Ode and the build of Unsung Anthem "
            "cannot be skipped")
    if not args.std == "c++2a" and not args.std == "c++17":
        _exit_rejecting_arguments(
            "C++ standard version is set to an invalid value: "
            "{}".format(args.std))
    if args.stdlib:
        if not args.stdlib == "libc++" and not args.stdlib == "libstdc++":
            _exit_rejecting_arguments(
                "C++ standard library implementation is set to an invalid "
                "value: {}".format(args.stdlib))
    if not args.cmake_generator == "Ninja" \
            and not args.cmake_generator == "Unix Makefiles" \
            and not args.cmake_generator == "Xcode" \
            and not args.cmake_generator == "Visual Studio 14 2015" \
            and not args.cmake_generator == "Visual Studio 15 2017" \
            and not args.cmake_generator == "Eclipse CDT4 - Ninja":
        _exit_rejecting_arguments(
            "CMake generator is set to an invalid value: "
            "{}".format(args.cmake_generator))


def _clean_delay():
    def _impl_write(index):
        sys.stdout.write(
            diagnostics.RED + "\b{!s}".format(index) + diagnostics.ENDC)
        sys.stdout.flush()
        time.sleep(1)
        return index
    sys.stdout.write(
        diagnostics.RED + "Starting a clean build in  " + diagnostics.ENDC)
    index_list = [_impl_write(i) for i in reversed(range(0, 4))]
    print(diagnostics.RED + "\b\b\b\bnow." + diagnostics.ENDC)
    return index_list


def _set_up_build(args):
    shell.DRY_RUN = args.dry_run
    shell.ECHO_DEFAULT = args.verbose_build

    diagnostics.VERBOSE = args.verbose_build
    diagnostics.DEBUG = args.verbose_build

    diagnostics.debug_head("Starting the setup phase")

    if args.build_subdir is None:
        args.build_subdir = workspace.compute_build_subdir(args)

    diagnostics.trace(
        "The build subdirectory is set to {}".format(args.build_subdir))

    _validate_arguments(args)

    data.build = Mapping(
        args=args, source_root=ANTHEM_SOURCE_ROOT,
        build_root=os.path.join(ANTHEM_BUILD_ROOT, args.build_subdir),
        install_root=os.path.join(args.install_prefix, args.anthem_version),
        checkout_root=ANTHEM_CHECKOUT_ROOT, products=PRODUCT_CONFIG,
        host_target=args.host_target, std=args.std, stdlib=args.stdlib,
        visual_studio=args.cmake_generator == "Visual Studio 14 2015"
                      or args.cmake_generator == "Visual Studio 15 2017",
        lua_with_cmake=platform.system() == "Windows")

    data.build["local_root"] = os.path.join(data.build.build_root, "local")

    if args.clean:
        _clean_delay()
        shell.rmtree(path=data.build.build_root)

    shell.makedirs(data.build.build_root)
    shell.makedirs(data.build.local_root)
    shell.makedirs(data.build.checkout_root)
    shell.makedirs(data.build.install_root)
    shell.makedirs(os.path.join(data.build.install_root, "bin"))
    shell.makedirs(os.path.join(data.build.install_root, "include"))
    shell.makedirs(os.path.join(data.build.install_root, "lib"))

    os.environ["TOOLCHAINS"] = "default"
    data.build.toolchain = host_toolchain(args=args)

    set_arguments_to_toolchain(args=args, toolchain=data.build.toolchain)

    data.build["ci"] = "CI" in os.environ and os.environ["CI"]

    if args.auth_token:
        data.build["github_token"] = args.auth_token
    elif "ODE_OAUTH" in os.environ:
        data.build["github_token"] = str(os.environ["ODE_OAUTH"])
    elif "ANTHEM_OAUTH" in os.environ:
        data.build["github_token"] = str(os.environ["ANTHEM_OAUTH"])

    data.build.connection_protocol = defaults.PROTOCOL

    diagnostics.debug_head("Setup phase is done")


def _build_tools():
    diagnostics.debug_head("Starting the tool setup phase")
    args = data.build.args
    toolchain = data.build.toolchain

    for key, product in data.build.products.items():
        diagnostics.trace("Checking if {} needs to be built".format(
            product.repr))
        should_build = reflection.build_call(product, "should_build")
        only_anthem = not args.build_anthem and product.anthem_only
        if only_anthem:
            diagnostics.note(
                "{} is not built as it is only required by Unsung Anthem "
                "which is not built".format(product.repr))
        if product.is_tool and should_build and not only_anthem:
            diagnostics.trace_head("Entering the build of {}".format(
                product.repr))
            reflection.build_call(product, "do_build")
            diagnostics.debug_ok("{} is now built".format(product.repr))
        elif product.is_tool and not should_build:
            diagnostics.trace("{} is not built".format(product.repr))

    diagnostics.fine("The Ode library name is set to {}".format(args.ode_name))
    diagnostics.fine("The Ode test executable name is set to {}".format(
        args.ode_test_name))

    diagnostics.fine("The Unsung Anthem executable name is set to {}".format(
        args.anthem_name))
    diagnostics.fine("The Unsung Anthem library name is set to {}".format(
        args.anthem_lib_name))
    diagnostics.fine(
        "The Unsung Anthem test executable name is set to "
        "{}".format(args.anthem_test_name))

    diagnostics.fine("The host C compiler is set to {}".format(toolchain.cc))
    diagnostics.fine("The host C++ compiler is set to {}".format(
        toolchain.cxx))
    diagnostics.fine("Make is set to {}".format(toolchain.make))
    diagnostics.fine("MSBuild is set to {}".format(toolchain.msbuild))
    diagnostics.fine("Ninja is set to {}".format(toolchain.ninja))
    diagnostics.fine("CMake is set to {}".format(toolchain.cmake))
    diagnostics.fine("git is set to {}".format(toolchain.git))

    diagnostics.fine("The C++ standard version is {}".format(data.build.std))

    if data.build.stdlib:
        diagnostics.fine("The C++ standard library is {}".format(
            data.build.stdlib))

    diagnostics.debug_head("Tool setup phase is done")


def _build_dependencies():
    args = data.build.args
    data.build["dependencies"] = Mapping()
    data.build.dependencies["build"] = list()

    for key, product in data.build.products.items():
        should_build = reflection.build_call(product, "should_build")
        only_anthem = not args.build_anthem and product.anthem_only
        if not product.is_tool and should_build and not only_anthem:
            diagnostics.trace_head("Entering the build of {}".format(
                product.repr))
            if not reflection.product_exists(product) \
                    or not reflection.build_function_exists(
                        product=product, function="do_build"):
                diagnostics.trace(
                    "The product package of {} either doesn't exists or "
                    "doesn't contain function 'build'".format(product.repr))
                diagnostics.trace(
                    "Thus, {} will be built using the default copy "
                    "function".format(product.repr))
                common.build.copy_build(
                    product=product, subdir=product.build_subdir)
            else:
                reflection.build_call(product, "do_build")
            diagnostics.debug_ok("{} is now built".format(product.repr))
        elif not product.is_tool and not should_build:
            diagnostics.trace("{} is not built".format(product.repr))


def _invoke():
    diagnostics.debug_head("Starting the build phase")
    args = data.build.args

    _build_dependencies()

    ode_p = data.build.products.ode
    anthem_p = data.build.products.anthem

    if args.build_ode:
        diagnostics.debug_head("Entering the build of {}".format(ode_p.repr))
        ode.build.do_build(lib=True, test=False)

    if args.build_anthem:
        diagnostics.debug_head("Entering the build of {}".format(
            anthem_p.repr))
        anthem.build.do_build(lib=False, test=False)

    if args.build_anthem_lib:
        diagnostics.debug_head("Entering the build of {} library".format(
            anthem_p.repr))
        anthem.build.do_build(lib=True, test=False)

    if args.build_test:
        ode_test = args.build_ode and not args.build_anthem
        if ode_test:
            diagnostics.debug_head("Entering the build of {} tests".format(
                ode_p.repr))
            ode.build.do_build(lib=False, test=True)
        else:
            diagnostics.debug_head("Entering the build of {} tests".format(
                anthem_p.repr))
            anthem.build.do_build(lib=False, test=True)

        if platform.system() == "Windows":
            if ode_test:
                # TODO
                test_run_dir = os.path.join(ode.build.ode_build_dir(
                    lib=False, test=True), args.ode_build_variant)
            else:
                test_run_dir = os.path.join(anthem.build.anthem_build_dir(
                    lib=False, test=True), args.anthem_build_variant)
        else:
            test_run_dir = os.path.join(data.build.install_root, "bin")
        if not args.enable_gcov:
            with shell.pushd(test_run_dir):
                if ode_test:
                    exe_name = args.ode_test_name
                else:
                    exe_name = args.anthem_test_name
                if platform.system() == "Windows":
                    test_executable = os.path.join(
                        test_run_dir, "{}.exe".format(exe_name))
                else:
                    test_executable = os.path.join(test_run_dir, exe_name)
                shell.call([test_executable], echo=True)

    diagnostics.debug_head("Build phase is done")


def initialize_runtime_environment():
    """
    Change the program environment for building.
    """
    os.umask(0o022)
    # Unset environment variables that might affect how tools behave.
    for flag in ["MAKEFLAGS"]:
        os.environ.pop(flag, None)


def main_preset():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description="Builds Obliging Ode and Unsung Anthem using a preset.")
    parser.add_argument(
        "-n", "--dry-run",
        help="print the commands that would be executed, but do not execute "
             "them",
        action="store_true",
        default=False)
    parser.add_argument(
        "--preset-file",
        help="load presets from the specified file",
        metavar="PATH",
        action="append",
        dest="preset_file_names",
        default=[])
    parser.add_argument(
        "--preset",
        help="use the specified option preset",
        metavar="NAME")
    parser.add_argument(
        "--show-presets",
        help="list all presets and exit",
        action="store_true")
    parser.add_argument(
        "-j", "--jobs",
        help="the number of parallel build jobs to use",
        type=int,
        dest="build_jobs")
    parser.add_argument(
        "preset_substitutions_raw",
        help="'name=value' pairs that are substituted in the preset",
        nargs="*",
        metavar="SUBSTITUTION")
    parser.add_argument(
        "--expand-build-script-invocation",
        help="Print the expanded build-script invocation generated "
             "by the preset, but do not run the preset",
        action="store_true")
    args = parser.parse_args()

    if not args.preset_file_names:
        args.preset_file_names = [
            os.path.join(HOME, ".ode-build-presets"),
            os.path.join(HOME, ".anthem-build-presets"),
            os.path.join(
                ANTHEM_SOURCE_ROOT, ANTHEM_REPO_NAME, "utils",
                "build-presets.ini")
        ]

    if args.show_presets:
        for name in sorted(
                get_all_preset_names(args.preset_file_names), key=str.lower):
            print(name)
        return 0

    if not args.preset:
        diagnostics.fatal("missing --preset option")

    args.preset_substitutions = {}

    for arg in args.preset_substitutions_raw:
        name, value = arg.split("=", 1)
        args.preset_substitutions[name] = value

    preset_args = get_preset_options(
        args.preset_substitutions, args.preset_file_names, args.preset)

    if platform.system() == "Windows":
        build_script_args = [sys.executable, sys.argv[0]]
    else:
        build_script_args = [sys.argv[0]]

    if args.dry_run:
        build_script_args += ["--dry-run"]
    build_script_args += preset_args
    if args.build_jobs:
        build_script_args += ["--jobs", str(args.build_jobs)]

    diagnostics.note("Using preset '{}', which expands to \n\n{}\n".format(
        args.preset, shell.quote_command(build_script_args)))

    if args.expand_build_script_invocation:
        return 0

    shell.caffeinate(build_script_args)

    return 0


def main_normal():
    """
    Run the build script.
    """
    if sys.version_info.major == 2:
        diagnostics.warn("You're using Python {}".format(sys.version))
        diagnostics.warn(
            "You should really update to Python 3 to make the world a better "
            "place!")
    else:
        diagnostics.fine("You're using Python {}".format(sys.version))
        diagnostics.fine("You seem to have an excellent taste!")
    parser = driver_arguments.create_argument_parser()
    # TODO Unknown args
    args, unknown_args = parser.parse_known_args(
        list(arg for arg in sys.argv[1:] if arg != '--'))
    _set_up_build(args)
    checkout.update()
    _build_tools()
    _invoke()
    return 0


def main():
    """
    The entry point function of the script.
    """
    if not ANTHEM_SOURCE_ROOT:
        diagnostics.fatal(
            "Could not infer source root directory (forgot to set "
            "$ANTHEM_SOURCE_ROOT environment variable?)")

    if not os.path.isdir(ANTHEM_SOURCE_ROOT):
        diagnostics.fatal(
            "Source root directory '{}' does not exist (forgot to set "
            "$ANTHEM_SOURCE_ROOT environment "
            "variable?)".format(ANTHEM_SOURCE_ROOT))
    if any([(opt.startswith("--preset") or opt == "--show-presets")
            for opt in sys.argv[1:]]):
        return main_preset()
    return main_normal()


if __name__ == "__main__":
    sys.exit(main())
