#!/usr/bin/env python

# utils/build-script ---------------------------------------------*- python -*-
#
# This source file is part of the Unsung Anthem open source project and is
# adapted from the Swift.org open source project.
#
# Copyright (c) 2017 Venturesome Stone
# Licensed under GNU Affero General Public License v3.0


"""
Usage:
  build-script --preset NAME [--preset-file PATH] [-n]
               [--expand-build-script-invocation]
  build-script --show-presets
  build-script [-n | --dry-run] [--clean | --clean-checkout | --clean-build]
               [--build-system NAME] [--ninja | --make | --xcode]
               [--std VERSION | --c++17 | --c++14 | --c++11]
               [--darwin-deployment-version VERSION] [--setup-clion]
               [--executable-name NAME --test-executable-name NAME]
               [--travis]

Options:
  --preset NAME         Use the specified option preset.
  --preset-file PATH    Load presets from the specified file.

  -n, --dry-run         Print the commands that would be executed, but do not
                        execute them.

  --expand-build-script-invocation
                        Print the expanded build-script invocation generated by
                        the preset, but do not run the preset.

  --show-presets        List all presets and exit.

  -c, --clean           Do a clean build.
  --clean-checkout      Re-download the dependencies before the build.
  --clean-build         Delete the build directory before the build.

  --build-system NAME   Set the build system to be used to build Unsung Anthem.
                        Possible values are bazel and cmake [default: cmake].

  --ninja               Use the Ninja generator of CMake (default is Ninja).
  -m, --make            Use the Unix Makefile generator of CMake (default is
                        Ninja).
  -x, --xcode           Use the Xcode generator of CMake (default is Ninja).

  --std VERSION         Set the C++ Standard version.
  --c++17               Set the C++ Standard version to C++17.
  --c++14               Set the C++ Standard version to C++14.
  --c++11               Set the C++ Standard version to C++11.

  --darwin-deployment-version VERSION
                        The minimum deployment target version for macOS in
                        format MAJOR.MINOR.

  --setup-clion         Installs only the dependencies for CLion configuration
                        and prints the necessary CMake arguments to set into
                        CLion settings.

  --executable-name NAME
                        The name of the Unsung Anthem executable file (please
                        note that this is not a path).
  --test-executable-name NAME
                        The name of the Unsung Anthem test executable file
                        (please note that this is not a path).

  --travis              The build is done in a Travis CI environment.
"""
import argparse
import multiprocessing
import os
import sys
import time

from anthem_build_support.anthem_build_support import \
    (arguments,
     build,
     diagnostics,
     migration,
     shell)

from anthem_build_support.anthem_build_support.call import \
    call_without_sleeping

from anthem_build_support.anthem_build_support.presets import \
    (get_all_preset_names,
     get_preset_options)

from anthem_build_support.anthem_build_support.variables import \
    (HOME,
     ANTHEM_BUILD_ROOT,
     ANTHEM_REPO_NAME,
     ANTHEM_SOURCE_ROOT)

from anthem_build_support.anthem_build_support.products import (bazel, ninja)

from anthem_build_support.anthem_build_support.targets import DeploymentTarget
from anthem_build_support.anthem_build_support.toolchain import host_toolchain
from anthem_build_support.anthem_build_support.workspace import \
    (Workspace,
     compute_build_subdir,
     compute_install_subdir)


def initialize_runtime_environment():
    """
    Change the program environment for building.
    """

    # Set an appropriate default umask.
    os.umask(0o022)

    # Unset environment variables that might affect how tools behave.
    for v in ['MAKEFLAGS']:
        os.environ.pop(v, None)


def clean_delay():
    """
    Provide a short delay so accidentally invoked clean builds can be
    cancelled.

    :return:
    """

    sys.stdout.write('Starting clean build in  ')

    for i in range(3, 0, -1):
        sys.stdout.write('\b%d' % i)
        sys.stdout.flush()
        time.sleep(1)

    print('\b\b\b\bnow.')


def main_preset_(raw_options):
    # Set the names of the files from which the presets are looked up from.
    preset_file_names = [raw_options['--preset-file']] \
        if (raw_options['--preset-file'] is not None) and not (
        len(raw_options['--preset-file']) == 0) \
        else [os.path.join(HOME, ".anthem-build-presets"),
              os.path.join(ANTHEM_SOURCE_ROOT,
                           ANTHEM_REPO_NAME,
                           "utils",
                           "build-presets.ini")]

    # If the option for only showing the presets is set, print the presets and
    # exit.
    if raw_options['--show-presets']:
        for name in sorted(get_all_preset_names(preset_file_names),
                           key=str.lower):
            print(name)
        return 0

    if raw_options['--preset'] is None:
        diagnostics.fatal("missing --preset option")

    # TODO Add parsing the preset substitutions here.

    preset_args = get_preset_options({},
                                     preset_file_names,
                                     raw_options['--preset'])

    # build_script_args = [sys.argv[0]]
    build_script_args = []

    if raw_options['--dry-run']:
        build_script_args += ["--dry-run"]

    # build_script_args += preset_args
    for a in preset_args:
        build_script_args += [a]

    diagnostics.note("using preset '"
                     + raw_options['--preset']
                     + "', which expands to \n\n"
                     + shell.quote_command(build_script_args)
                     + "\n")

    if raw_options['--expand-build-script-invocation']:
        return 0

    # call_without_sleeping(build_script_args)
    main(build_script_args)

    return 0


# Main entry point for the preset mode.
def main_preset():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description="""Builds Unsung Anthem using a preset.""")
    parser.add_argument(
        "-n", "--dry-run",
        help="print the commands that would be executed, but do not execute "
             "them",
        action="store_true",
        default=False)
    parser.add_argument(
        "--preset-file",
        help="load presets from the specified file",
        metavar="PATH",
        action="append",
        dest="preset_file_names",
        default=[])
    parser.add_argument(
        "--preset",
        help="use the specified option preset",
        metavar="NAME")
    parser.add_argument(
        "--show-presets",
        help="list all presets and exit",
        action=arguments.action.optional_bool)
    parser.add_argument(
        "-j", "--jobs",
        help="the number of parallel build jobs to use",
        type=int,
        dest="build_jobs")
    parser.add_argument(
        "preset_substitutions_raw",
        help="'name=value' pairs that are substituted in the preset",
        nargs="*",
        metavar="SUBSTITUTION")
    parser.add_argument(
        "--expand-build-script-invocation",
        help="Print the expanded build-script invocation generated "
             "by the preset, but do not run the preset",
        action=arguments.action.optional_bool)
    args = parser.parse_args()

    if len(args.preset_file_names) == 0:
        args.preset_file_names = [
            os.path.join(HOME, ".anthem-build-presets"),
            os.path.join(
                ANTHEM_SOURCE_ROOT, ANTHEM_REPO_NAME, "utils",
                "build-presets.ini")
        ]

    if args.show_presets:
        for name in sorted(get_all_preset_names(args.preset_file_names),
                           key=str.lower):
            print(name)
        return 0

    if not args.preset:
        diagnostics.fatal("missing --preset option")

    args.preset_substitutions = {}

    for arg in args.preset_substitutions_raw:
        name, value = arg.split("=", 1)
        args.preset_substitutions[name] = value

    preset_args = get_preset_options(
        args.preset_substitutions, args.preset_file_names, args.preset)

    build_script_args = [sys.argv[0]]
    if args.dry_run:
        build_script_args += ["--dry-run"]
    build_script_args += preset_args
    if args.build_jobs:
        build_script_args += ["--jobs", str(args.build_jobs)]

    diagnostics.note(
        "using preset '" + args.preset + "', which expands to \n\n" +
        shell.quote_command(build_script_args) + "\n")

    if args.expand_build_script_invocation:
        return 0

    call_without_sleeping(build_script_args)
    return 0


# Main entry point for the normal mode.
def main_normal():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument(
        "-n", "--dry-run",
        help="print the commands that would be executed, but do not execute "
             "them",
        action="store_true",
        default=False)
    parser.add_argument(
        "--no-legacy-impl", dest="legacy_impl",
        help="avoid legacy implementation",
        action="store_false",
        default=True)

    targets_group = parser.add_argument_group(
        title="Host and cross-compilation targets")
    targets_group.add_argument(
        "--host-target",
        help="The host target. LLVM, Clang, and Swift will be built for this "
             "target. The built LLVM and Clang will be used to compile Swift "
             "for the cross-compilation targets.",
        default=DeploymentTarget.host_target().name)

    projects_group = parser.add_argument_group(
        title="Options to select projects")
    projects_group.add_argument(
        "--build-ninja",
        help="build the Ninja tool",
        action=arguments.action.optional_bool)

    extra_actions_group = parser.add_argument_group(
        title="Extra actions to perform before or in addition to building")
    extra_actions_group.add_argument(
        "-c", "--clean",
        help="do a clean build",
        action="store_true")

    build_variant_group = parser.add_mutually_exclusive_group(required=False)
    build_variant_group.add_argument(
        "-d", "--debug",
        help="build the Debug variant of everything (default)",
        action="store_const",
        const="Debug",
        dest="build_variant")
    build_variant_group.add_argument(
        "-r", "--release-debuginfo",
        help="build the RelWithDebInfo variant of everything (default is "
             "Debug)",
        action="store_const",
        const="RelWithDebInfo",
        dest="build_variant")
    build_variant_group.add_argument(
        "-R", "--release",
        help="build the Release variant of everything (default is Debug)",
        action="store_const",
        const="Release",
        dest="build_variant")

    # FIXME: This should be one option using choices=[...]
    cmake_generator_group = parser.add_argument_group(
        title="Select the CMake generator")
    cmake_generator_group.add_argument(
        "-x", "--xcode",
        help="use CMake's Xcode generator (default is Ninja)",
        action="store_const",
        const="Xcode",
        dest="cmake_generator")
    cmake_generator_group.add_argument(
        "-m", "--make",
        help="use CMake's Makefile generator (default is Ninja)",
        action="store_const",
        const="Unix Makefiles",
        dest="cmake_generator")
    cmake_generator_group.add_argument(
        "-e", "--eclipse",
        help="use CMake's Eclipse generator (default is Ninja)",
        action="store_const",
        const="Eclipse CDT4 - Ninja",
        dest="cmake_generator")

    run_tests_group = parser.add_argument_group(
        title="Run tests")

    # NOTE: We can't merge -t and --test, because nargs='?' makes
    #       `-ti` to be treated as `-t=i`.
    run_tests_group.add_argument(
        "-t",
        help="test Swift after building",
        action="store_const",
        const=True,
        dest="test")
    run_tests_group.add_argument(
        "--test",
        help="test Swift after building",
        action=arguments.action.optional_bool)
    run_tests_group.add_argument(
        "-o",
        help="run the test suite in optimized mode too (implies --test)",
        action="store_const",
        const=True,
        dest="test_optimized")
    run_tests_group.add_argument(
        "--test-optimized",
        help="run the test suite in optimized mode too (implies --test)",
        action=arguments.action.optional_bool)

    run_build_group = parser.add_argument_group(
        title="Run build")
    run_build_group.add_argument(
        "-S", "--skip-build",
        help="generate build directory only without building",
        action="store_true")

    parser.add_argument(
        "--build-subdir",
        help="name of the directory under $ANTHEM_BUILD_ROOT where the build "
             "products will be placed",
        metavar="PATH")
    parser.add_argument(
        "--install-prefix",
        help="The installation prefix. This is where built Unsung Anthem "
             "products (like bin, lib, and include) will be installed.",
        metavar="PATH")
    parser.add_argument(
        "--install-symroot",
        help="the path to install debug symbols into",
        metavar="PATH")

    parser.add_argument(
        "-j", "--jobs",
        help="the number of parallel build jobs to use",
        type=int,
        dest="build_jobs",
        default=multiprocessing.cpu_count())

    parser.add_argument(
        "--build-system",
        help="set the build system to be used to build Unsung Anthem, "
             "possible values are bazel and cmake",
        type=arguments.type.executable,
        metavar="PATH")

    parser.add_argument(
        "--darwin-xcrun-toolchain",
        help="the name of the toolchain to use on Darwin",
        default="default")
    parser.add_argument(
        "--cmake",
        help="the path to a CMake executable that will be used to build "
             "Swift",
        type=arguments.type.executable,
        metavar="PATH")

    parser.add_argument(
        "--host-cc",
        help="the absolute path to CC, the 'clang' compiler for the host "
             "platform. Default is auto detected.",
        type=arguments.type.executable,
        metavar="PATH")
    parser.add_argument(
        "--host-cxx",
        help="the absolute path to CXX, the 'clang++' compiler for the host "
             "platform. Default is auto detected.",
        type=arguments.type.executable,
        metavar="PATH")

    parser.add_argument(
        "--darwin-deployment-version",
        help="minimum deployment target version for macOS",
        metavar="MAJOR.MINOR",
        default="10.9")

    parser.add_argument(
        "--extra-cmake-options",
        help="Pass through extra options to CMake in the form of comma "
             "separated options '-DCMAKE_VAR1=YES,-DCMAKE_VAR2=/tmp'. Can be "
             "called multiple times to add multiple such options.",
        action=arguments.action.concat,
        type=arguments.type.shell_split,
        default=[])

    parser.add_argument(
        "--build-args",
        help="arguments to the build tool. This would be prepended to the "
             "default argument that is '-j8' when CMake generator is "
             "\"Ninja\".",
        type=arguments.type.shell_split,
        default=[])

    args = migration.parse_args(parser, sys.argv[1:])

    # Set the dry run setting of the shell utilities.
    shell.dry_run = args.dry_run

    # Set the CMake generator if one is not set.
    if args.cmake_generator is None:
        args.cmake_generator = 'Ninja'

    # TODO Set the build variant of Unsung Anthem.
    args.anthem_build_variant = 'Debug'

    # Set the build subdirectory.
    build_subdir = compute_build_subdir(args) \
        if args.build_subdir is None else args.build_subdir

    # Set the installation subdirectory.
    install_subdir = compute_install_subdir(args) \
        if args.install_subdir is None else args.install_subdir

    # Create the workspace object containing the build-related directories.
    workspace = Workspace(source_root=ANTHEM_SOURCE_ROOT,
                          build_root=os.path.join(ANTHEM_BUILD_ROOT,
                                                  build_subdir),
                          install_root=os.path.join(ANTHEM_BUILD_ROOT,
                                                    install_subdir))

    # Clean build directory if requested.
    if args.clean_build:
        clean_delay()
        shell.rmtree(workspace.build_root)
        shell.rmtree(workspace.install_root)

    # Make the call of update-checkout.
    update_checkout = [os.path.join(ANTHEM_SOURCE_ROOT,
                                    ANTHEM_REPO_NAME,
                                    'utils',
                                    'update-checkout')]

    if args.clean_checkout:
        update_checkout += ['--clean']

    if not ('bazel' == args.build_system):
        update_checkout += ['--skip-repository']
        update_checkout += ['bazel']

    if args.travis:
        update_checkout += ['--travis']

    # Call the update-checkout script.
    call_without_sleeping(update_checkout)

    # Set the executable name.
    if args.executable_name is None:
        args.executable_name = 'unsung-anthem-%s' % args.host_target

    # Set the test executable name.
    if args.test_executable_name is None:
        args.test_executable_name = 'test-%s' % args.executable_name

    # Create the build directory.
    shell.makedirs(workspace.build_root)

    # Create the install directory.
    shell.makedirs(workspace.install_root)

    # Prepare and validate the toolchain.
    toolchain = host_toolchain(xcrun_toolchain=args.darwin_xcrun_toolchain)
    os.environ['TOOLCHAINS'] = args.darwin_xcrun_toolchain

    if args.host_cc is not None:
        toolchain.cc = args.host_cc

    if args.host_cxx is not None:
        toolchain.cxx = args.host_cxx

    if args.cmake is not None:
        toolchain.cmake = args.cmake

    # Build Bazel if required, which will update the toolchain.
    if 'bazel' == args.build_system and toolchain.bazel is None:
        bazel.build(args=args, toolchain=toolchain, workspace=workspace)

    elif args.cmake_generator == 'Ninja' or toolchain.ninja is None:
        ninja.build(args=args, toolchain=toolchain, workspace=workspace)

    # Build CMake.
    build.build_cmake(args=args, toolchain=toolchain, workspace=workspace)

    # Build LLVM
    build.build_llvm(args=args, toolchain=toolchain, workspace=workspace)

    diagnostics.note('The host C compiler is set to ' + str(toolchain.cc))
    diagnostics.note('The host C++ compiler is set to ' + str(toolchain.cxx))
    diagnostics.note('CMake is set to ' + str(toolchain.cmake))

    if toolchain.bazel is None:
        if os.path.exists(os.path.join(workspace.install_root, 'bin')):
            toolchain.bazel = os.path.join(workspace.install_root, 'bin',
                                           'bazel')
            diagnostics.note('Bazel is set to ' + str(toolchain.bazel))
        else:
            diagnostics.note('Bazel is set to None')
    else:
        diagnostics.note('Bazel is set to ' + str(toolchain.bazel))

    # Tell the user that this set-up will not build the final product but
    # rather only set it up for CLion.
    if args.setup_clion:
        diagnostics.note('The CLion set-up is enabled and thus the final '
                         'Unsung Anthem executable will not be built')

    # Build Unsung Anthem and its dependencies.
    if 'bazel' == args.build_system:
        build.bazel_build(args=args, toolchain=toolchain, workspace=workspace)

    elif 'cmake' == args.build_system:
        build.cmake_build(args=args, toolchain=toolchain, workspace=workspace)

        # Run tests.
        if args.test and not args.setup_clion:
            with shell.pushd(workspace.build_dir(args.host_target,
                                                 'anthem-test')):
                call_without_sleeping([os.path.join(
                    workspace.build_dir(args.host_target, 'anthem-test'),
                    args.test_executable_name)])

    return 0


def main():
    # First check if the root directory environment variable of the build is
    # set.
    if not ANTHEM_SOURCE_ROOT:
        diagnostics.fatal("could not infer source root directory (forgot to "
                          "set $ANTHEM_SOURCE_ROOT environment variable?)")

    # Then check if the root directory of the build exists and is a directory.
    if not os.path.isdir(ANTHEM_SOURCE_ROOT):
        diagnostics.fatal("source root directory \'"
                          + ANTHEM_SOURCE_ROOT
                          + "\' does not exist (forgot to set "
                            "$ANTHEM_SOURCE_ROOT environment variable?)")

    # Determine if the script is invoked in the preset mode and dispatch
    # accordingly.
    if any([(opt.startswith("--preset") or opt == "--show-presets")
            for opt in sys.argv[1:]]):
        return main_preset()
    else:
        return main_normal()


if __name__ == '__main__':
    sys.exit(main())
