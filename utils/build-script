#!/usr/bin/env python

# utils/build-script ---------------------------------------------*- python -*-
#
# This source file is part of the Unsung Anthem open source project and is
# adapted from the Swift.org open source project.
#
# Copyright (c) 2017 Venturesome Stone
# Licensed under GNU Affero General Public License v3.0


import argparse
import multiprocessing
import os
import sys
import time

from anthem_build_support.anthem_build_support import \
    (arguments,
     build,
     checkout,
     diagnostics,
     migration,
     shell)

from anthem_build_support.anthem_build_support.call import \
    call_without_sleeping

from anthem_build_support.anthem_build_support.presets import \
    (get_all_preset_names,
     get_preset_options)

from anthem_build_support.anthem_build_support.variables import \
    (HOME,
     ANTHEM_BUILD_ROOT,
     ANTHEM_REPO_NAME,
     ANTHEM_SOURCE_ROOT,
     SCRIPT_DIR)

from anthem_build_support.anthem_build_support.products import (bazel, ninja)

from anthem_build_support.anthem_build_support.targets import DeploymentTarget
from anthem_build_support.anthem_build_support.toolchain import host_toolchain
from anthem_build_support.anthem_build_support.workspace import \
    (Workspace,
     compute_build_subdir,
     compute_install_prefix)


def exit_rejecting_arguments(message, parser=None):
    print(message)  # TODO , file=sys.stderr)
    if parser:
        parser.print_usage(sys.stderr)
    sys.exit(2)  # 2 is the same as `argparse` error exit code.


def apply_default_arguments(args):
    # Make the name of the build system lower case as it is supposed to be
    # case insensitive.
    if args.build_system is not None:
        args.build_system = args.build_system.lower()

    # Default is to build LLVM when not in a Travis CI environment.
    if not args.travis:
        args.build_llvm = True

    # The default CMake generator is Ninja.
    if args.cmake_generator is None:
        args.cmake_generator = 'Ninja'

    # The default build variant is Debug.
    if args.build_variant is None:
        args.build_variant = 'Debug'

    # Propagate the build variant.
    if args.llvm_build_variant is None:
        args.llvm_build_variant = args.build_variant

    if args.anthem_build_variant is None:
        args.anthem_build_variant = args.build_variant

    # Assertions are enabled by default.
    if args.assertions is None:
        args.assertions = True

    # Propagate the assertion option.
    if args.llvm_assertions is None:
        args.llvm_assertions = args.assertions

    if args.anthem_assertions is None:
        args.anthem_assertions = args.assertions

    # Propagate --clean.
    if args.clean:
        args.clean_build = True
        args.clean_checkout = True

    if args.skip_test:
        args.test = False

    # The tests are run by default.
    if args.test is None:
        args.test = True

    if args.clion:
        args.test = False
        args.test_optimized = False
        args.build_test = False
        args.build_test_optimized = False

    # --test-optimized implies --test and --build-test-optimized.
    if args.test_optimized:
        args.test = True
        args.build_test_optimized = True

    # --test implies --build-test.
    if args.test:
        args.build_test = True

    # Propagate global --skip-build
    if args.skip_build:
        args.skip_build_linux = True
        args.skip_build_macos = True
        args.skip_build_freebsd = True
        args.skip_build_cygwin = True
        args.skip_build_windows = True
        args.build_llvm = False
        args.build_test = False
        args.build_test_optimized = False

    # Propagate the --skip-build-llvm
    if args.skip_build_llvm:
        args.build_llvm = False

    # Skip Bazel on checkout update if the build system is not Bazel.
    if not ('bazel' == args.build_system):
        args.skip_repository_list += ['bazel']

    # Skip LLVM on the checkout update if LLVM will not be built.
    if not args.build_llvm:
        args.skip_repository_list += ['llvm']

    # Set the build subdirectory.
    if args.build_subdir is None:
        args.build_subdir = compute_build_subdir(args)

    # Set the installation subdirectory.
    if args.install_prefix is None:
        args.install_prefix = compute_install_prefix(args)

    # Set the executable name.
    if args.executable_name is None:
        args.executable_name = 'unsung-anthem-%s' % args.host_target

    # Set the test executable name.
    if args.test_executable_name is None:
        args.test_executable_name = 'test-%s' % args.executable_name


def validate_arguments(args):
    # Check the validity of C++ standard version.
    if not ('c++1z' == args.std or 'c++14' == args.std or 'c++11' == args.std):
        exit_rejecting_arguments('C++ standard version is set to an invalid '
                                 'value: ' + str(args.cmake_generator))

    # Check the validity of CMake generator.
    if not ('Ninja' == args.cmake_generator
            or 'Unix Makefiles' == args.cmake_generator
            or 'Xcode' == args.cmake_generator
            or 'Eclipse CDT4 - Ninja' == args.cmake_generator):
        exit_rejecting_arguments('CMake generator is set to an invalid value: '
                                 + str(args.cmake_generator))

    # Check the validity of the collective build variant.
    if not ('Debug' == args.build_variant
            or 'RelWithDebInfo' == args.build_variant
            or 'Release' == args.build_variant):
        exit_rejecting_arguments('Build variant is set to an invalid value: '
                                 + str(args.build_variant))

    # Check the validity of the LLVM build variant.
    if not ('Debug' == args.llvm_build_variant
            or 'RelWithDebInfo' == args.llvm_build_variant
            or 'Release' == args.llvm_build_variant):
        exit_rejecting_arguments('LLVM build variant is set to an invalid '
                                 'value: ' + str(args.llvm_build_variant))

    # Check the validity of the Unsung Anthem build variant.
    if not ('Debug' == args.anthem_build_variant
            or 'RelWithDebInfo' == args.anthem_build_variant
            or 'Release' == args.anthem_build_variant):
        exit_rejecting_arguments('Unsung Anthem build variant is set to an '
                                 'invalid value: '
                                 + str(args.anthem_build_variant))

    # Check the validity of the build system.
    if not ('cmake'.lower() == args.build_system.lower()
            or 'bazel'.lower() == args.build_system.lower()):
        exit_rejecting_arguments('The build system is set to an invalid '
                                 'value: ' + str(args.build_system))


def initialize_runtime_environment():
    """
    Change the program environment for building.
    """

    # Set an appropriate default umask.
    os.umask(0o022)

    # Unset environment variables that might affect how tools behave.
    for v in ['MAKEFLAGS']:
        os.environ.pop(v, None)


def clean_delay():
    """
    Provide a short delay so accidentally invoked clean builds can be
    cancelled.

    :return:
    """

    sys.stdout.write('Starting clean build in  ')

    for i in range(3, 0, -1):
        sys.stdout.write('\b%d' % i)
        sys.stdout.flush()
        time.sleep(1)

    print('\b\b\b\bnow.')


# Main entry point for the preset mode.
def main_preset():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description="""Builds Unsung Anthem using a preset.""")
    parser.add_argument(
        "-n", "--dry-run",
        help="print the commands that would be executed, but do not execute "
             "them",
        action="store_true",
        default=False)
    clean_group = parser.add_mutually_exclusive_group(required=False)
    clean_group.add_argument(
        "-c", "--clean",
        help="do a clean build",
        action="store_true")
    clean_group.add_argument(
        "--clean-checkout",
        help="redownload all of the dependencies before build",
        action="store_true")
    clean_group.add_argument(
        "--clean-build",
        help="do a clean build but do not redownload the dependencies",
        action="store_true")
    parser.add_argument(
        "--preset-file",
        help="load presets from the specified file",
        metavar="PATH",
        action="append",
        dest="preset_file_names",
        default=[])
    parser.add_argument(
        "--preset",
        help="use the specified option preset",
        metavar="NAME")
    parser.add_argument(
        "--show-presets",
        help="list all presets and exit",
        action=arguments.action.optional_bool)
    parser.add_argument(
        "-j", "--jobs",
        help="the number of parallel build jobs to use",
        type=int,
        dest="build_jobs")
    parser.add_argument(
        "preset_substitutions_raw",
        help="'name=value' pairs that are substituted in the preset",
        nargs="*",
        metavar="SUBSTITUTION")
    parser.add_argument(
        "--expand-build-script-invocation",
        help="Print the expanded build-script invocation generated "
             "by the preset, but do not run the preset",
        action=arguments.action.optional_bool)
    args = parser.parse_args()

    if len(args.preset_file_names) == 0:
        args.preset_file_names = [
            os.path.join(HOME, ".anthem-build-presets"),
            os.path.join(
                ANTHEM_SOURCE_ROOT, ANTHEM_REPO_NAME, "utils",
                "build-presets.ini")
        ]

    if args.show_presets:
        for name in sorted(get_all_preset_names(args.preset_file_names),
                           key=str.lower):
            print(name)
        return 0

    if not args.preset:
        diagnostics.fatal("missing --preset option")

    args.preset_substitutions = {}

    for arg in args.preset_substitutions_raw:
        name, value = arg.split("=", 1)
        args.preset_substitutions[name] = value

    preset_args = get_preset_options(
        args.preset_substitutions, args.preset_file_names, args.preset)

    build_script_args = [sys.argv[0]]
    if args.dry_run:
        build_script_args += ["--dry-run"]
    if args.clean:
        build_script_args += ["--clean"]
    elif args.clean_checkout:
        build_script_args += ['--clean-checkout']
    elif args.clean_build:
        build_script_args += ["--clean-build"]
    build_script_args += preset_args
    if args.build_jobs:
        build_script_args += ["--jobs", str(args.build_jobs)]

    diagnostics.note(
        "using preset '" + args.preset + "', which expands to \n\n" +
        shell.quote_command(build_script_args) + "\n")

    if args.expand_build_script_invocation:
        return 0

    call_without_sleeping(build_script_args)
    return 0


# Main entry point for the normal mode.
def main_normal():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument(
        "-n", "--dry-run",
        help="print the commands that would be executed, but do not execute "
             "them",
        action="store_true",
        default=False)
    parser.add_argument(
        "--no-legacy-impl", dest="legacy_impl",
        help="avoid legacy implementation",
        action="store_false",
        default=True)

    ci_group = parser.add_argument_group(title="Continuous integration")
    ci_group.add_argument(
        "--ci",
        help="build in a CI environment",
        action="store_true")
    ci_group.add_argument(
        "--travis",
        help="build in a Travis CI environment",
        action="store_true")

    targets_group = parser.add_argument_group(
        title="Host and cross-compilation targets - These options do not have "
              "any effect yet")
    targets_group.add_argument(
        "--host-target",
        help="The host target. LLVM, Clang, and Unsung Anthem will be built "
             "for this target. The built LLVM and Clang will be used to "
             "compile Unsung Anthem for the cross-compilation targets.",
        default=DeploymentTarget.host_target().name)
    targets_group.add_argument(
        "--cross-compile-hosts",
        help="A space separated list of targets to cross-compile Unsung "
             "Anthem tools for. Can be used multiple times.",
        action=arguments.action.concat, type=arguments.type.shell_split,
        default=[])

    projects_group = parser.add_argument_group(
        title="Options to select projects")
    projects_group.add_argument(
        "-l", "--llvm",
        help="build LLVM",
        action="store_true",
        dest="build_llvm")
    projects_group.add_argument(
        "--build-test",
        help="build the Unsung Anthem tests",
        action="store_true",
        dest="build_test")
    projects_group.add_argument(
        "--build-test-optimized",
        help="build the Unsung Anthem tests with optimization",
        action="store_true",
        dest="build_test_optimized")
    projects_group.add_argument(
        "--build-ninja",
        help="build the Ninja tool",
        action=arguments.action.optional_bool)

    extra_actions_group = parser.add_argument_group(
        title="Extra actions to perform before or in addition to building")
    extra_actions_group.add_argument(
        "-c", "--clean",
        help="do a clean build",
        action="store_true")
    extra_actions_group.add_argument(
        "--clean-checkout",
        help="redownload all of the dependencies before build",
        action="store_true")
    extra_actions_group.add_argument(
        "--clean-build",
        help="do a clean build but do not redownload the dependencies",
        action="store_true")

    cpp_version_group = parser.add_mutually_exclusive_group(required=False)
    cpp_version_group.add_argument(
        "--std",
        help="build using the specified C++ standard version",
        default="c++14",
        dest="std")
    cpp_version_group.add_argument(
        "--c++1z",
        help="build using the C++17 standard version (default is C++14)",
        action="store_const",
        const="c++17",
        dest="std")
    cpp_version_group.add_argument(
        "--c++14",
        help="build using the C++14 standard version (default)",
        action="store_const",
        const="c++14",
        dest="std")
    cpp_version_group.add_argument(
        "--c++11",
        help="build using the C++11 standard version (default is C++14)",
        action="store_const",
        const="c++11",
        dest="std")

    build_variant_group = parser.add_mutually_exclusive_group(required=False)
    build_variant_group.add_argument(
        "-d", "--debug",
        help="build the Debug variant of everything (default)",
        action="store_const",
        const="Debug",
        dest="build_variant")
    build_variant_group.add_argument(
        "-r", "--release-debuginfo",
        help="build the RelWithDebInfo variant of everything (default is "
             "Debug)",
        action="store_const",
        const="RelWithDebInfo",
        dest="build_variant")
    build_variant_group.add_argument(
        "-R", "--release",
        help="build the Release variant of everything (default is Debug)",
        action="store_const",
        const="Release",
        dest="build_variant")

    build_variant_override_group = parser.add_argument_group(
        title="Override build variant for a specific project")
    build_variant_override_group.add_argument(
        "--debug-llvm",
        help="build the Debug variant of LLVM",
        action="store_const",
        const="Debug",
        dest="llvm_build_variant")
    build_variant_override_group.add_argument(
        "--debug-anthem",
        help="build the Debug variant of Unsung Anthem",
        action="store_const",
        const="Debug",
        dest="anthem_build_variant")

    assertions_group = parser.add_mutually_exclusive_group(required=False)
    assertions_group.add_argument(
        "--assertions",
        help="enable assertions in all projects",
        action="store_const",
        const=True,
        dest="assertions")
    assertions_group.add_argument(
        "--no-assertions",
        help="disable assertions in all projects",
        action="store_const",
        const=False,
        dest="assertions")

    assertions_override_group = parser.add_argument_group(
        title="Control assertions in a specific project")
    assertions_override_group.add_argument(
        "--llvm-assertions",
        help="enable assertions in LLVM",
        action="store_const",
        const=True,
        dest="llvm_assertions")
    assertions_override_group.add_argument(
        "--no-llvm-assertions",
        help="disable assertions in LLVM",
        action="store_const",
        const=False,
        dest="llvm_assertions")
    assertions_override_group.add_argument(
        "--anthem-assertions",
        help="enable assertions in Unsung Anthem",
        action="store_const",
        const=True,
        dest="anthem_assertions")
    assertions_override_group.add_argument(
        "--no-anthem-assertions",
        help="disable assertions in Unsung Anthem",
        action="store_const",
        const=False,
        dest="anthem_assertions")

    # FIXME: This should be one option using choices=[...]
    cmake_generator_group = parser.add_argument_group(
        title="Select the CMake generator")
    cmake_generator_group.add_argument(
        "-x", "--xcode",
        help="use CMake's Xcode generator (default is Ninja)",
        action="store_const",
        const="Xcode",
        dest="cmake_generator")
    cmake_generator_group.add_argument(
        "-m", "--make",
        help="use CMake's Makefile generator (default is Ninja)",
        action="store_const",
        const="Unix Makefiles",
        dest="cmake_generator")
    cmake_generator_group.add_argument(
        "-e", "--eclipse",
        help="use CMake's Eclipse generator (default is Ninja)",
        action="store_const",
        const="Eclipse CDT4 - Ninja",
        dest="cmake_generator")

    run_tests_group = parser.add_argument_group(
        title="Run tests")

    # NOTE: We cannot merge -t and --test, because nargs='?' makes
    #       `-ti` to be treated as `-t=i`.
    run_tests_group.add_argument(
        "-t",
        help="test Unsung Anthem after building (implies --build-test)",
        action="store_const",
        const=True,
        dest="test")
    run_tests_group.add_argument(
        "--test",
        help="test Unsung Anthem after building (implies --build-test)",
        action=arguments.action.optional_bool)
    run_tests_group.add_argument(
        "--skip-test",
        help="do not test Unsung Anthem after building",
        action=arguments.action.optional_bool)
    run_tests_group.add_argument(
        "-o",
        help="run the test suite in optimized mode too (implies --test and "
             "--build-test-optimized)",
        action="store_const",
        const=True,
        dest="test_optimized")
    run_tests_group.add_argument(
        "--test-optimized",
        help="run the test suite in optimized mode too (implies --test and "
             "--build-test-optimized)",
        action=arguments.action.optional_bool)

    run_build_group = parser.add_argument_group(
        title="Run build")
    run_build_group.add_argument(
        "-S", "--skip-build",
        help="generate build directory only without building",
        action="store_true")

    run_build_group.add_argument(
        "--clion",
        help="install the dependencies and generate the CMake command for "
             "setting up an CLion environment",
        action="store_true")

    run_build_group.add_argument(
        "--skip-build-linux",
        help="skip building Unsung Anthem for Linux",
        action=arguments.action.optional_bool)
    run_build_group.add_argument(
        "--skip-build-macos",
        help="skip building Unsung Anthem for macOS",
        action=arguments.action.optional_bool)
    run_build_group.add_argument(
        "--skip-build-freebsd",
        help="skip building Unsung Anthem for FreeBSD",
        action=arguments.action.optional_bool)
    run_build_group.add_argument(
        "--skip-build-cygwin",
        help="skip building Unsung Anthem for Cygwin",
        action=arguments.action.optional_bool)
    run_build_group.add_argument(
        "--skip-build-windows",
        help="skip building Unsung Anthem for Windows",
        action=arguments.action.optional_bool)

    run_build_group.add_argument(
        "--skip-build-llvm",
        help="skip building LLVM",
        action=arguments.action.optional_bool)

    checkout_group = parser.add_argument_group(title="Update checkout")
    checkout_group.add_argument(
        "--skip-repository",
        metavar="DIRECTORY",
        default=[],
        help="skip the specified repository",
        dest='skip_repository_list',
        action="append")

    checkout_group.add_argument(
        "--checkout-config",
        default=os.path.join(SCRIPT_DIR, "update-checkout-config.json"),
        help="checkout configuration file to use")

    parser.add_argument(
        '--disable-manual-tar',
        help='disable calling the "tar" executable on some archives on older '
             'Python versions',
        action='store_true')

    parser.add_argument(
        "--build-subdir",
        help="name of the directory under $ANTHEM_BUILD_ROOT where the build "
             "products will be placed",
        metavar="PATH")
    parser.add_argument(
        "--install-prefix",
        help="The installation prefix. This is where built Unsung Anthem "
             "products (like bin, lib, and include) will be installed.",
        metavar="PATH")

    parser.add_argument(
        "-j", "--jobs",
        help="the number of parallel build jobs to use",
        type=int,
        dest="build_jobs",
        default=multiprocessing.cpu_count())

    parser.add_argument(
        "--build-system",
        help="set the build system to be used to build Unsung Anthem, "
             "possible values are bazel and cmake (case insensitive)",
        metavar="NAME",
        default='cmake')

    parser.add_argument(
        "--darwin-xcrun-toolchain",
        help="the name of the toolchain to use on Darwin",
        default="default")
    parser.add_argument(
        "--cmake",
        help="the path to a CMake executable that will be used to build "
             "Unsung Anthem",
        type=arguments.type.executable,
        metavar="PATH")

    parser.add_argument(
        "--host-cc",
        help="the absolute path to CC, the 'clang' compiler for the host "
             "platform. Default is auto detected.",
        type=arguments.type.executable,
        metavar="PATH")
    parser.add_argument(
        "--host-cxx",
        help="the absolute path to CXX, the 'clang++' compiler for the host "
             "platform. Default is auto detected.",
        type=arguments.type.executable,
        metavar="PATH")

    parser.add_argument(
        "--executable-name",
        help="the name of the Unsung Anthem executable",
        metavar="NAME")
    parser.add_argument(
        "--test-executable-name",
        help="the name of the Unsung Anthem test executable",
        metavar="NAME")

    parser.add_argument(
        "--darwin-deployment-version",
        help="minimum deployment target version for macOS",
        metavar="MAJOR.MINOR",
        default="10.9")

    parser.add_argument(
        "--extra-cmake-options",
        help="Pass through extra options to CMake in the form of comma "
             "separated options '-DCMAKE_VAR1=YES,-DCMAKE_VAR2=/tmp'. Can be "
             "called multiple times to add multiple such options.",
        action=arguments.action.concat,
        type=arguments.type.shell_split,
        default=[])

    parser.add_argument(
        "--build-args",
        help="arguments to the build tool. This would be prepended to the "
             "default argument that is '-j8' when CMake generator is "
             "\"Ninja\".",
        type=arguments.type.shell_split,
        default=[])

    args = migration.parse_args(parser, sys.argv[1:])

    # Set the dry run setting of the shell utilities.
    shell.dry_run = args.dry_run

    # Apple the default values of the arguments to the args namespace.
    apply_default_arguments(args=args)

    # Create the workspace object containing the build-related directories.
    workspace = Workspace(source_root=ANTHEM_SOURCE_ROOT,
                          build_root=os.path.join(ANTHEM_BUILD_ROOT,
                                                  args.build_subdir),
                          install_root=os.path.join(ANTHEM_BUILD_ROOT,
                                                    args.install_prefix))

    # Clean build directory if requested.
    if args.clean_build:
        clean_delay()
        shell.rmtree(workspace.build_root)
        shell.rmtree(workspace.install_root)

    # Update the checkout.
    checkout.update(args)

    # Create the build directory.
    shell.makedirs(workspace.build_root)

    # Create the install directory.
    shell.makedirs(workspace.install_root)

    # Prepare and validate the toolchain.
    toolchain = host_toolchain(xcrun_toolchain=args.darwin_xcrun_toolchain)
    os.environ['TOOLCHAINS'] = args.darwin_xcrun_toolchain

    if args.host_cc is not None:
        toolchain.cc = args.host_cc

    if args.host_cxx is not None:
        toolchain.cxx = args.host_cxx

    if args.cmake is not None:
        toolchain.cmake = args.cmake

    # Build Bazel if required, which will update the toolchain.
    if 'bazel' == args.build_system and toolchain.bazel is None:
        bazel.build(args=args, toolchain=toolchain, workspace=workspace)

    elif args.cmake_generator == 'Ninja' or toolchain.ninja is None:
        ninja.build(args=args, toolchain=toolchain, workspace=workspace)

    # Build CMake.
    build.build_cmake(args=args, toolchain=toolchain, workspace=workspace)

    # Build LLVM.
    if args.build_llvm:
        build.build_llvm(args=args, toolchain=toolchain, workspace=workspace)

    diagnostics.note('The host C compiler is set to ' + str(toolchain.cc))
    diagnostics.note('The host C++ compiler is set to ' + str(toolchain.cxx))
    diagnostics.note('CMake is set to ' + str(toolchain.cmake))

    if toolchain.bazel is None:
        if os.path.exists(os.path.join(workspace.install_root, 'bin')):
            toolchain.bazel = os.path.join(workspace.install_root, 'bin',
                                           'bazel')
            diagnostics.note('Bazel is set to ' + str(toolchain.bazel))
        else:
            diagnostics.note('Bazel is set to None')
    elif 'bazel' == args.build_system:
        diagnostics.note('Bazel is set to ' + str(toolchain.bazel))

    # Tell the user that this set-up will not build the final product but
    # rather only set it up for CLion.
    if args.clion:
        diagnostics.note('The CLion set-up is enabled and thus the final '
                         'Unsung Anthem executable will not be built')

    # Build Unsung Anthem and its dependencies.
    if 'bazel' == args.build_system:
        build.bazel_build(args=args, toolchain=toolchain, workspace=workspace)

    elif 'cmake' == args.build_system:
        build.cmake_build(args=args, toolchain=toolchain, workspace=workspace)

        # Run tests.
        if args.test:
            with shell.pushd(workspace.build_dir(args.host_target,
                                                 'anthem-test')):
                call_without_sleeping([os.path.join(
                    workspace.build_dir(args.host_target, 'anthem-test'),
                    args.test_executable_name)])

    return 0


def main():
    # First check if the root directory environment variable of the build is
    # set.
    if not ANTHEM_SOURCE_ROOT:
        diagnostics.fatal("could not infer source root directory (forgot to "
                          "set $ANTHEM_SOURCE_ROOT environment variable?)")

    # Then check if the root directory of the build exists and is a directory.
    if not os.path.isdir(ANTHEM_SOURCE_ROOT):
        diagnostics.fatal("source root directory \'"
                          + ANTHEM_SOURCE_ROOT
                          + "\' does not exist (forgot to set "
                            "$ANTHEM_SOURCE_ROOT environment variable?)")

    # Determine if the script is invoked in the preset mode and dispatch
    # accordingly.
    if any([(opt.startswith("--preset") or opt == "--show-presets")
            for opt in sys.argv[1:]]):
        return main_preset()
    else:
        return main_normal()


if __name__ == '__main__':
    sys.exit(main())
