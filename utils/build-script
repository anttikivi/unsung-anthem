#!/usr/bin/env python

#===-------------------------- build-script -------------------*- python -*-===#
#
#                             Unsung Anthem
#
# This source file is part of the Unsung Anthem open source project.
#
# Copyright (c) 2017 Venturesome Stone
# Licensed under GNU Affero General Public License v3.0


"""
Use this tool to build, test, and prepare binary distribution archives of
Unsung Anthem.

Builds Unsung Anthem and its dependencies, incrementally, optionally testing
Unsung Anthem thereafter. Different build configurations are maintained in
parallel.
"""

from __future__ import print_function

import os
import sys
import time

from build_support import diagnostics, script

from build_support.presets import \
    get_all_preset_names, parse_preset_defaults, get_preset_options

from build_support.variables import ANTHEM_SOURCE_ROOT


def exit_rejecting_arguments(message, parser=None):
    """
    Prints an error message and terminates the program with the same error exit
    code as an 'argparse' error would. Optionally prints the program usage
    before exiting if the parser is provided.

    This function is not pure as it prints command line output and terminates
    the program.

    message -- the error message.
    parser -- a ArgumentParser whose usage is printed.
    """
    print(message, file=sys.stderr)
    if parser:
        parser.print_usage(sys.stderr)
    sys.exit(2)  # 2 is the same as 'argparse' error exit code.


def initialize_runtime_environment():
    """
    Change the program environment for building.
    """

    # Set an appropriate default umask.
    os.umask(0o022)

    # Unset environment variables that might affect how tools behave.
    for flag in ["MAKEFLAGS"]:
        os.environ.pop(flag, None)


def clean_delay():
    """
    Provide a short delay so accidentally invoked clean builds can be
    cancelled.
    """

    sys.stdout.write(diagnostics.WARNING + "Starting a clean build in  ")

    for i in range(3, 0, -1):
        sys.stdout.write(diagnostics.WARNING + "\b%d" % i)
        sys.stdout.flush()
        time.sleep(1)

    print(diagnostics.WARNING + "\b\b\b\bnow.")


def main_preset():
    """
    Resolve the preset information and run the build script with the arguments
    in the given preset.
    """
    args = script.create_preset_parser().parse_args()
    preset_files = script.preset_files(args)

    if args.show_presets:
        print("\n".join(sorted(get_all_preset_names(preset_files),
                               key=str.lower)))
        return 0

    if not args.preset:
        diagnostics.fatal("missing --preset option")

    preset_defaults = parse_preset_defaults(args)

    preset_args = get_preset_options(preset_defaults, preset_files,
                                     args.preset)

    # Run the new script with the Python executable if the build is done on
    # AppVeyor.
    if 'APPVEYOR' in os.environ.keys() and os.environ['APPVEYOR']:
        build_script_args = [sys.executable]
        build_script_args += [sys.argv[0]]
    else:
        build_script_args = [sys.argv[0]]

    if args.expand_build_script_invocation:
        return 0

    # shell.call_without_sleeping(build_script_args)
    return 0


def main_normal():
    return 0


def main():
    """
    The entry point function of the script.
    """

    if not ANTHEM_SOURCE_ROOT:
        diagnostics.fatal(
            "could not infer source root directory (forgot to set "
            "$ANTHEM_SOURCE_ROOT environment variable?)"
        )

    if not os.path.isdir(ANTHEM_SOURCE_ROOT):
        diagnostics.fatal(
            "source root directory \'"
            + ANTHEM_SOURCE_ROOT
            + "\' does not exist (forgot to set $ANTHEM_SOURCE_ROOT "
            "environment variable?)"
        )

    # Determine if the script is invoked in the preset mode and dispatch
    # accordingly.
    if any([(opt.startswith("--preset") or opt == "--show-presets")
            for opt in sys.argv[1:]]):
        return main_preset()

    # If the script is not run in the preset mode, run it in the normal mode.
    return main_normal()


if __name__ == '__main__':
    sys.exit(main())
