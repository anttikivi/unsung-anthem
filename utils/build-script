#!/usr/bin/env python

# utils/build-script ----------------------------------------------*- python -*-
#
# This source file is part of the Unsung Anthem open source project.
#
# Copyright (c) 2017 Venturesome Stone
# Licensed under GNU Affero General Public License v3.0

import argparse
import json
import multiprocessing
import os
import sys
import time

from anthem_build_support.anthem_build_support import \
    arguments, checkout, diagnostics, migration, shell

from anthem_build_support.anthem_build_support.presets import \
    get_all_preset_names, get_preset_options

from anthem_build_support.anthem_build_support.variables import \
    HOME, ANTHEM_BUILD_ROOT, ANTHEM_SOURCE_ROOT, ANTHEM_REPO_NAME, SCRIPT_DIR

from anthem_build_support.anthem_build_support.targets import DeploymentTarget

from anthem_build_support.anthem_build_support.toolchain import \
    register_tools, host_toolchain

from anthem_build_support.anthem_build_support.workspace import \
    Workspace, compute_build_subdir, compute_install_prefix

from anthem_build_support.anthem_build_support.products import \
    anthem, cat, catch, cmake, gcc, glfw, llvm, ninja, spdlog


def exit_rejecting_arguments(message, parser=None):
    print(message)  # TODO , file=sys.stderr)
    if parser:
        parser.print_usage(sys.stderr)
    sys.exit(2)  # 2 is the same as `argparse` error exit code.


def apply_default_arguments(args):
    if args.install_only:
        args.build_only = False
        args.test_only = False
        args.update_checkout_only = False
    elif args.build_only:
        args.install_only = False
        args.test_only = False
        args.update_checkout_only = False
    elif args.test_only:
        args.build_only = False
        args.install_only = False
        args.update_checkout_only = False
    elif args.update_checkout_only:
        args.build_only = False
        args.install_only = False
        args.test_only = False

    # If the build is done in Travis or AppVeyor, CI is true.
    if args.travis or args.appveyor:
        args.ci = True

    # Build LLVM if any LLVM-related options were specified.
    if args.llvm_build_variant is not None or args.llvm_assertions is not None:
        args.build_llvm = True

    # The default build variant is Debug.
    if args.build_variant is None:
        args.build_variant = 'Debug'

    # Propagate the build variant.
    if args.llvm_build_variant is None:
        args.llvm_build_variant = args.build_variant

    if args.anthem_build_variant is None:
        args.anthem_build_variant = args.build_variant

    if args.glfw_build_variant is None:
        args.glfw_build_variant = args.build_variant

    # Assertions are enabled by default.
    if args.assertions is None:
        args.assertions = True

    # Propagate the assertion option.
    if args.llvm_assertions is None:
        args.llvm_assertions = args.assertions

    if args.anthem_assertions is None:
        args.anthem_assertions = args.assertions

    # The default CMake generator is Ninja.
    if args.cmake_generator is None:
        args.cmake_generator = 'Ninja'

    # The default CMake generator on CLion is make.
    if args.clion:
        args.cmake_generator = 'Unix Makefiles'

    # Propagate --run-test.
    if args.test_only:
        args.clean = False
        args.clean_build = False

    # Propagate --clean.
    if args.clean:
        args.clean_build = True

    if args.clion:
        args.test = False
        args.test_optimized = False
        args.build_test = False
        args.build_test_optimized = False

    # --test-optimized implies --test and --build-test-optimized.
    if args.test_optimized:
        args.test = True
        args.build_test_optimized = True

    # --test implies --build-test.
    if args.test:
        args.build_test = True

    # By default, Ninja is not built on AppVeyor.
    if not args.build_ninja and args.cmake_generator == 'Visual Studio 14 2015':
        args.build_ninja = False

    # Propagate global --skip-build
    if args.skip_build:
        args.skip_build_anthem = True
        args.build_llvm = False
        args.build_gcc = False
        args.build_cmake = False
        args.build_ninja = False
        args.build_test = False
        args.build_test_optimized = False

    # Set the build subdirectory.
    if args.build_subdir is None:
        args.build_subdir = compute_build_subdir(args)

    # Set the installation subdirectory.
    if args.install_prefix is None:
        args.install_prefix = compute_install_prefix(args)

    # Set the executable name.
    if args.executable_name is None:
        args.executable_name = 'unsung-anthem-{}'.format(args.host_target)

    # Set the test executable name.
    if args.test_executable_name is None:
        args.test_executable_name = 'test-{}'.format(args.executable_name)

    # Set the Visual Studio option to true if the CMake generator is Visual
    # Studio.
    if args.cmake_generator.startswith('Visual Studio'):
        args.visual_studio = True
    else:
        args.visual_studio = False


def apply_default_version_arguments(args):
    with open(args.checkout_config) as f:
        config = json.load(f)

    dependencies = config['dependencies']

    if args.llvm_version == 'default':
        llvm_node = dependencies['llvm']
        args.llvm_version = llvm_node['default_version']

    args.version_info['llvm'] = args.llvm_version

    if args.gcc_version == 'default':
        gcc_node = dependencies['gcc']
        args.gcc_version = gcc_node['default_version']

    args.version_info['gcc'] = args.gcc_version

    cmake_node = dependencies['cmake']

    if args.cmake_version == 'default':
        if args.cmake_major_version == 'default':
            args.cmake_major_version = \
                str(cmake_node['default_version']['major'])

        if args.cmake_minor_version == 'default':
            args.cmake_minor_version = \
                str(cmake_node['default_version']['minor'])

        if args.cmake_patch_version == 'default':
            args.cmake_patch_version = \
                str(cmake_node['default_version']['patch'])

        args.cmake_version = "{}.{}.{}".format(args.cmake_major_version,
                                               args.cmake_minor_version,
                                               args.cmake_patch_version)
    else:
        args.cmake_major_version = args.cmake_version.split('.')[0]
        args.cmake_minor_version = args.cmake_version.split('.')[1]
        args.cmake_patch_version = args.cmake_version.split('.')[2]

    args.version_info['cmake'] = args.cmake_version

    args.version_info['cmake_info'] = {
        'major': args.cmake_major_version,
        'minor': args.cmake_minor_version,
        'patch': args.cmake_patch_version
    }

    if args.ninja_version == 'default':
        ninja_node = dependencies['ninja']
        args.ninja_version = ninja_node['default_version']

    args.version_info['ninja'] = args.ninja_version

    if args.catch_version == 'default':
        catch_node = dependencies['catch']
        args.catch_version = catch_node['default_version']

    args.version_info['catch'] = args.catch_version

    if args.glfw_version == 'default':
        glfw_node = dependencies['glfw']
        args.glfw_version = glfw_node['default_version']

    args.version_info['glfw'] = args.glfw_version

    if args.spdlog_version == 'default':
        spdlog_node = dependencies['spdlog']
        args.spdlog_version = spdlog_node['default_version']

    args.version_info['spdlog'] = args.spdlog_version

    if args.cat_version == 'default':
        cat_node = dependencies['cat']
        args.cat_version = cat_node['default_version']

    args.version_info['cat'] = args.cat_version


def apply_default_checkout_skip_arguments(args, toolchain):
    # Skip LLVM on the checkout update if LLVM will not be built.
    if not args.build_llvm:
        args.skip_repository_list += ['llvm']

    # Skip GCC on the checkout update if GCC will not be built.
    if not args.build_gcc:
        args.skip_repository_list += ['gcc']

    # Skip CMake on the checkout update if CMake will not be built.
    if not args.build_cmake and toolchain.cmake is not None:
        args.skip_repository_list += ['cmake']

    # Skip Ninja on the checkout update if Ninja will not be built.
    if not args.build_ninja and toolchain.ninja is not None:
        args.skip_repository_list += ['ninja']

    # Skip Catch on the checkout update if the tests are not built.
    if not args.build_test:
        args.skip_repository_list += ['catch']


def validate_arguments(args):
    # Check the validity of C++ standard version.
    if not ('latest' == args.std
            or 'c++latest' == args.std
            or 'c++17' == args.std
            or 'c++14' == args.std):
        exit_rejecting_arguments('C++ standard version is set to an invalid '
                                 'value: ' + str(args.cmake_generator))

    # Check the validity of CMake generator.
    if not ('Ninja' == args.cmake_generator
            or 'Unix Makefiles' == args.cmake_generator
            or 'Xcode' == args.cmake_generator
            or 'Visual Studio 14 2015' == args.cmake_generator
            or 'Visual Studio 15 2017' == args.cmake_generator
            or 'Eclipse CDT4 - Ninja' == args.cmake_generator):
        exit_rejecting_arguments('CMake generator is set to an invalid value: '
                                 + str(args.cmake_generator))

    # Check the validity of the collective build variant.
    if not ('Debug' == args.build_variant
            or 'RelWithDebInfo' == args.build_variant
            or 'Release' == args.build_variant):
        exit_rejecting_arguments('Build variant is set to an invalid value: '
                                 + str(args.build_variant))

    # Check the validity of the LLVM build variant.
    if not ('Debug' == args.llvm_build_variant
            or 'RelWithDebInfo' == args.llvm_build_variant
            or 'Release' == args.llvm_build_variant):
        exit_rejecting_arguments('LLVM build variant is set to an invalid '
                                 'value: ' + str(args.llvm_build_variant))

    # Check the validity of the Unsung Anthem build variant.
    if not ('Debug' == args.anthem_build_variant
            or 'RelWithDebInfo' == args.anthem_build_variant
            or 'Release' == args.anthem_build_variant):
        exit_rejecting_arguments('Unsung Anthem build variant is set to an '
                                 'invalid value: '
                                 + str(args.anthem_build_variant))

    # Check the validity of the GLFW build variant.
    if not ('Debug' == args.glfw_build_variant
            or 'RelWithDebInfo' == args.glfw_build_variant
            or 'Release' == args.glfw_build_variant):
        exit_rejecting_arguments('GLFW build variant is set to an '
                                 'invalid value: '
                                 + str(args.anthem_build_variant))

    # Check the validity of the compiler tool to be looked for.
    if not ('clang' == args.main_tool
            or 'gcc' == args.main_tool
            or 'msbuild' == args.main_tool):
        exit_rejecting_arguments('The main tool is set to an invalid value: '
                                 + str(args.anthem_build_variant))


def initialize_runtime_environment():
    """
    Change the program environment for building.
    """

    # Set an appropriate default umask.
    os.umask(0o022)

    # Unset environment variables that might affect how tools behave.
    for v in ['MAKEFLAGS']:
        os.environ.pop(v, None)


def clean_delay():
    """
    Provide a short delay so accidentally invoked clean builds can be
    cancelled.

    :return:
    """

    sys.stdout.write('Starting clean build in  ')

    for i in range(3, 0, -1):
        sys.stdout.write('\b%d' % i)
        sys.stdout.flush()
        time.sleep(1)

    print('\b\b\b\bnow.')


def main_preset():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description="""Builds Unsung Anthem using a preset.""")
    parser.add_argument(
        "-n", "--dry-run",
        help="print the commands that would be executed, but do not execute "
             "them",
        action="store_true",
        default=False)

    clean_group = parser.add_mutually_exclusive_group(required=False)
    clean_group.add_argument(
        "-c", "--clean",
        help="do a clean build",
        action="store_true")
    clean_group.add_argument(
        "--clean-build",
        help="do a clean build but do not redownload the dependencies",
        action="store_true")

    parser.add_argument(
        "--preset-file",
        help="load presets from the specified file",
        metavar="PATH",
        action="append",
        dest="preset_file_names",
        default=[])
    parser.add_argument(
        "--preset",
        help="use the specified option preset",
        metavar="NAME",
        required=True)
    parser.add_argument(
        "--show-presets",
        help="list all presets and exit",
        action=arguments.action.optional_bool)

    build_actions_group = parser.add_mutually_exclusive_group(required=False)
    build_actions_group.add_argument(
        "--install",
        help="only install the project dependencies",
        action="store_true",
        dest="install_only")
    build_actions_group.add_argument(
        "--build",
        help="build the project without installing the dependencies",
        action="store_true",
        dest="build_only")
    build_actions_group.add_argument(
        "--run-test",
        help="run the tests without installing the dependencies or building "
             "the project",
        action="store_true",
        dest="test_only")
    build_actions_group.add_argument(
        "--update-checkout",
        help="only update the checkout",
        action="store_true",
        dest="update_checkout_only")

    parser.add_argument(
        "-j", "--jobs",
        help="the number of parallel build jobs to use",
        type=int,
        dest="build_jobs")
    parser.add_argument(
        "preset_substitutions_raw",
        help="'name=value' pairs that are substituted in the preset",
        nargs="*",
        metavar="SUBSTITUTION")
    parser.add_argument(
        "--expand-build-script-invocation",
        help="Print the expanded build-script invocation generated "
             "by the preset, but do not run the preset",
        action=arguments.action.optional_bool)
    args = parser.parse_args()

    if len(args.preset_file_names) == 0:
        args.preset_file_names = [
            os.path.join(HOME, ".anthem-build-presets"),
            os.path.join(
                ANTHEM_SOURCE_ROOT, ANTHEM_REPO_NAME, "utils",
                "build-presets.ini")
        ]

    if args.show_presets:
        for name in sorted(get_all_preset_names(args.preset_file_names),
                           key=str.lower):
            print(name)
        return 0

    if not args.preset:
        diagnostics.fatal("missing --preset option")

    args.preset_substitutions = {}

    for arg in args.preset_substitutions_raw:
        name, value = arg.split("=", 1)
        args.preset_substitutions[name] = value

    preset_args = get_preset_options(
        args.preset_substitutions, args.preset_file_names, args.preset)

    # Run the new script with the Python executable if the build is done on
    # AppVeyor.
    if 'APPVEYOR' in os.environ.keys() and os.environ['APPVEYOR']:
        build_script_args = [sys.executable]
        build_script_args += [sys.argv[0]]
    else:
        build_script_args = [sys.argv[0]]

    if args.dry_run:
        build_script_args += ["--dry-run"]
    if args.clean:
        build_script_args += ["--clean"]
    elif args.clean_build:
        build_script_args += ["--clean-build"]
    if args.install_only:
        build_script_args += ["--install"]
    elif args.build_only:
        build_script_args += ['--build']
    elif args.test_only:
        build_script_args += ['--run-test']
    elif args.update_checkout_only:
        build_script_args += ['--update-checkout']
    build_script_args += preset_args
    if args.build_jobs:
        build_script_args += ["--jobs", str(args.build_jobs)]

    diagnostics.note(
        "using preset '" + args.preset + "', which expands to \n\n" +
        shell.quote_command(build_script_args) + "\n")

    if args.expand_build_script_invocation:
        return 0

    shell.call_without_sleeping(build_script_args)
    return 0


def main_normal():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument(
        "-n", "--dry-run",
        help="print the commands that would be executed, but do not execute "
             "them",
        action="store_true",
        default=False)

    ci_group = parser.add_argument_group(title="Continuous integration")
    ci_group.add_argument(
        "--ci",
        help="build in a CI environment",
        action="store_true")
    ci_group.add_argument(
        "--travis",
        help="build in a Travis CI environment",
        action="store_true")
    ci_group.add_argument(
        "--appveyor",
        help="build in an AppVeyor CI environment",
        action="store_true")

    targets_group = parser.add_argument_group(
        title="Host and cross-compilation targets - These options do not have "
              "any effect yet")
    targets_group.add_argument(
        "--host-target",
        help="The host target. LLVM, Clang, and Unsung Anthem will be built "
             "for this target. The built LLVM and Clang will be used to "
             "compile Unsung Anthem for the cross-compilation targets.",
        default=DeploymentTarget.host_target().name)
    targets_group.add_argument(
        "--cross-compile-hosts",
        help="A space separated list of targets to cross-compile Unsung "
             "Anthem tools for. Can be used multiple times.",
        action=arguments.action.concat, type=arguments.type.shell_split,
        default=[])

    projects_group = parser.add_argument_group(
        title="Options to select projects")
    projects_group.add_argument(
        "-l", "--llvm",
        help="build LLVM and use the built LLVM",
        action="store_true",
        dest="build_llvm")
    projects_group.add_argument(
        "--build-gcc",
        help="build GNU Compiler Collection and use the built compiler",
        action="store_true",
        dest="build_gcc")
    projects_group.add_argument(
        "--build-cmake",
        help="build CMake",
        action="store_true")
    projects_group.add_argument(
        "--build-ninja",
        help="build the Ninja tool",
        action=arguments.action.optional_bool)
    projects_group.add_argument(
        "--build-test",
        help="build the Unsung Anthem tests",
        action="store_true",
        dest="build_test")
    projects_group.add_argument(
        "--build-test-optimized",
        help="build the Unsung Anthem tests with optimization",
        action="store_true",
        dest="build_test_optimized")

    build_actions_group = parser.add_mutually_exclusive_group(required=False)
    build_actions_group.add_argument(
        "--install",
        help="only install the project dependencies",
        action="store_true",
        dest="install_only")
    build_actions_group.add_argument(
        "--build",
        help="build the project without installing the dependencies",
        action="store_true",
        dest="build_only")
    build_actions_group.add_argument(
        "--run-test",
        help="run the tests without installing the dependencies or building "
             "the project",
        action="store_true",
        dest="test_only")
    build_actions_group.add_argument(
        "--update-checkout",
        help="only update the checkout",
        action="store_true",
        dest="update_checkout_only")

    extra_actions_group = parser.add_argument_group(
        title="Extra actions to perform before or in addition to building")
    extra_actions_group.add_argument(
        "-c", "--clean",
        help="do a clean build",
        action="store_true")
    extra_actions_group.add_argument(
        "--clean-build",
        help="do a clean build but do not redownload the dependencies",
        action="store_true")

    cpp_version_group = parser.add_mutually_exclusive_group(required=False)
    cpp_version_group.add_argument(
        "--std",
        help="build using the specified C++ standard version",
        default="c++14",
        dest="std")
    cpp_version_group.add_argument(
        "--c++latest",
        help="build using the latest features of the C++ standard version and"
             "its drafts (default is C++14)",
        action="store_const",
        const="c++latest",
        dest="std")
    cpp_version_group.add_argument(
        "--c++17",
        help="build using the C++17 standard version (default is C++14)",
        action="store_const",
        const="c++17",
        dest="std")
    cpp_version_group.add_argument(
        "--c++14",
        help="build using the C++14 standard version (default)",
        action="store_const",
        const="c++14",
        dest="std")

    build_variant_group = parser.add_mutually_exclusive_group(required=False)
    build_variant_group.add_argument(
        "-d", "--debug",
        help="build the Debug variant of everything (default)",
        action="store_const",
        const="Debug",
        dest="build_variant")
    build_variant_group.add_argument(
        "-r", "--release-debuginfo",
        help="build the RelWithDebInfo variant of everything (default is "
             "Debug)",
        action="store_const",
        const="RelWithDebInfo",
        dest="build_variant")
    build_variant_group.add_argument(
        "-R", "--release",
        help="build the Release variant of everything (default is Debug)",
        action="store_const",
        const="Release",
        dest="build_variant")

    build_variant_override_group = parser.add_argument_group(
        title="Override build variant for a specific project")
    build_variant_override_group.add_argument(
        "--debug-llvm",
        help="build the Debug variant of LLVM",
        action="store_const",
        const="Debug",
        dest="llvm_build_variant")
    build_variant_override_group.add_argument(
        "--debug-anthem",
        help="build the Debug variant of Unsung Anthem",
        action="store_const",
        const="Debug",
        dest="anthem_build_variant")
    build_variant_override_group.add_argument(
        "--debug-glfw",
        help="build the Debug variant of GLFW",
        action="store_const",
        const="Debug",
        dest="glfw_build_variant")

    assertions_group = parser.add_mutually_exclusive_group(required=False)
    assertions_group.add_argument(
        "--assertions",
        help="enable assertions in all projects",
        action="store_const",
        const=True,
        dest="assertions")
    assertions_group.add_argument(
        "--no-assertions",
        help="disable assertions in all projects",
        action="store_const",
        const=False,
        dest="assertions")

    assertions_override_group = parser.add_argument_group(
        title="Control assertions in a specific project")
    assertions_override_group.add_argument(
        "--llvm-assertions",
        help="enable assertions in LLVM",
        action="store_const",
        const=True,
        dest="llvm_assertions")
    assertions_override_group.add_argument(
        "--no-llvm-assertions",
        help="disable assertions in LLVM",
        action="store_const",
        const=False,
        dest="llvm_assertions")
    assertions_override_group.add_argument(
        "--anthem-assertions",
        help="enable assertions in Unsung Anthem",
        action="store_const",
        const=True,
        dest="anthem_assertions")
    assertions_override_group.add_argument(
        "--no-anthem-assertions",
        help="disable assertions in Unsung Anthem",
        action="store_const",
        const=False,
        dest="anthem_assertions")

    # FIXME: This should be one option using choices=[...]
    cmake_generator_group = parser.add_argument_group(
        title="Select the CMake generator")
    cmake_generator_group.add_argument(
        "-x", "--xcode",
        help="use CMake's Xcode generator (default is Ninja)",
        action="store_const",
        const="Xcode",
        dest="cmake_generator")
    cmake_generator_group.add_argument(
        "-m", "--make",
        help="use CMake's Makefile generator (default is Ninja)",
        action="store_const",
        const="Unix Makefiles",
        dest="cmake_generator")
    cmake_generator_group.add_argument(
        "--visual-studio-14",
        help="use CMake's Visual Studio 2015 generator (default is Ninja)",
        action="store_const",
        const="Visual Studio 14 2015",
        dest="cmake_generator")
    cmake_generator_group.add_argument(
        "--visual-studio-2015",
        help="use CMake's Visual Studio 2015 generator (default is Ninja)",
        action="store_const",
        const="Visual Studio 14 2015",
        dest="cmake_generator")
    cmake_generator_group.add_argument(
        "--visual-studio-15",
        help="use CMake's Visual Studio 2017 generator (default is Ninja)",
        action="store_const",
        const="Visual Studio 15 2017",
        dest="cmake_generator")
    cmake_generator_group.add_argument(
        "--visual-studio-2017",
        help="use CMake's Visual Studio 2017 generator (default is Ninja)",
        action="store_const",
        const="Visual Studio 15 2017",
        dest="cmake_generator")
    cmake_generator_group.add_argument(
        "-e", "--eclipse",
        help="use CMake's Eclipse generator (default is Ninja)",
        action="store_const",
        const="Eclipse CDT4 - Ninja",
        dest="cmake_generator")

    run_tests_group = parser.add_argument_group(
        title="Run tests")

    # NOTE: We cannot merge -t and --test, because nargs='?' makes
    #       `-ti` to be treated as `-t=i`.
    run_tests_group.add_argument(
        "-t",
        help="test Unsung Anthem after building (implies --build-test)",
        action="store_const",
        const=True,
        dest="test")
    run_tests_group.add_argument(
        "--test",
        help="test Unsung Anthem after building (implies --build-test)",
        action=arguments.action.optional_bool)
    run_tests_group.add_argument(
        "-o",
        help="run the test suite in optimized mode too (implies --test and "
             "--build-test-optimized)",
        action="store_const",
        const=True,
        dest="test_optimized")
    run_tests_group.add_argument(
        "--test-optimized",
        help="run the test suite in optimized mode too (implies --test and "
             "--build-test-optimized)",
        action=arguments.action.optional_bool)

    run_build_group = parser.add_argument_group(
        title="Run build")
    run_build_group.add_argument(
        "-S", "--skip-build",
        help="generate build directory only without building",
        action="store_true")

    run_build_group.add_argument(
        "--clion",
        help="install the dependencies and generate the CMake command for "
             "setting up an CLion environment",
        action="store_true")

    run_build_group.add_argument(
        "--skip-build-anthem",
        help="skip building Unsung Anthem",
        action=arguments.action.optional_bool)

    checkout_group = parser.add_argument_group(title="Update checkout")
    checkout_group.add_argument(
        "--skip-repository",
        metavar="DIRECTORY",
        default=[],
        help="skip the specified repository. To skip a specific LLVM project, "
             "add the prefix llvm- to the name of the project.",
        dest='skip_repository_list',
        action="append")
    checkout_group.add_argument(
        "--checkout-config",
        default=os.path.join(SCRIPT_DIR, "update-checkout-config.json"),
        help="checkout configuration file to use")

    version_group = parser.add_argument_group(title="Dependency and project "
                                                    "version information")
    version_group.add_argument(
        "--llvm-version",
        metavar="MAJOR.MINOR.PATCH",
        default='default',
        help="the LLVM version")
    version_group.add_argument(
        "--gcc-version",
        metavar="MAJOR.MINOR.PATCH",
        default='default',
        help="the GNU Compiler Collection version")
    version_group.add_argument(
        "--cmake-major-version",
        metavar="MAJOR",
        default='default',
        help="the CMake major version")
    version_group.add_argument(
        "--cmake-minor-version",
        metavar="MINOR",
        default='default',
        help="the CMake minor version")
    version_group.add_argument(
        "--cmake-patch-version",
        metavar="PATCH",
        default='default',
        help="the CMake patch version")
    version_group.add_argument(
        "--cmake-version",
        metavar="MAJOR.MINOR.PATCH",
        default='default',
        help="the CMake version. Overrides the major, minor, and patch "
             "settings if set")
    version_group.add_argument(
        "--ninja-version",
        metavar="MAJOR.MINOR.PATCH",
        default='default',
        help="the Ninja version")
    version_group.add_argument(
        "--catch-version",
        metavar="MAJOR.MINOR.PATCH",
        default='default',
        help="the Catch version")
    version_group.add_argument(
        "--glfw-version",
        metavar="MAJOR.MINOR.PATCH",
        default='default',
        help="the GLFW version")
    version_group.add_argument(
        "--spdlog-version",
        metavar="MAJOR.MINOR.PATCH",
        default='default',
        help="the spdlog version")
    version_group.add_argument(
        "--cat-version",
        metavar="MAJOR.MINOR",
        default='default',
        help="the cat library version")

    parser.add_argument(
        '--disable-manual-tar',
        help='disable calling the "tar" executable on some archives on older '
             'Python versions',
        action='store_true')

    parser.add_argument(
        "--build-subdir",
        help="name of the directory under $ANTHEM_BUILD_ROOT where the build "
             "products will be placed",
        metavar="PATH")
    parser.add_argument(
        "--install-prefix",
        help="The installation prefix. This is where built Unsung Anthem "
             "products (like bin, lib, and include) will be installed.",
        metavar="PATH")

    parser.add_argument(
        "-j", "--jobs",
        help="the number of parallel build jobs to use",
        type=int,
        dest="build_jobs",
        default=multiprocessing.cpu_count())

    parser.add_argument(
        "--darwin-xcrun-toolchain",
        help="the name of the toolchain to use on Darwin",
        default="default")
    parser.add_argument(
        "--cmake",
        help="the path to a CMake executable that will be used to build "
             "Unsung Anthem",
        type=arguments.type.executable,
        metavar="PATH")

    parser.add_argument(
        "--host-cc",
        help="the absolute path to CC, the C compiler for the host platform. "
             "Default is auto detected.",
        type=arguments.type.executable,
        metavar="PATH")
    parser.add_argument(
        "--host-cxx",
        help="the absolute path to CXX, the C++ compiler for the host "
             "platform. Default is auto detected.",
        type=arguments.type.executable,
        metavar="PATH")
    parser.add_argument(
        "--msbuild",
        help="the absolute path to MSBuild, the Microsoft Visual Studio "
             "compiler for the host platform. Default is auto detected.",
        type=arguments.type.executable,
        metavar="PATH")
    parser.add_argument(
        "--main-tool",
        help="the name of the main tool to be looked by the script. The "
             "default is clang.",
        metavar="NAME",
        default='clang')

    msbuild_group = parser.add_argument_group(title="MSBuild options")
    msbuild_group.add_argument(
        "--msbuild-logger",
        help="the absolute path to MSBuild logger",
        metavar="PATH")

    parser.add_argument(
        "--executable-name",
        help="the name of the Unsung Anthem executable",
        metavar="NAME")
    parser.add_argument(
        "--test-executable-name",
        help="the name of the Unsung Anthem test executable",
        metavar="NAME")

    parser.add_argument(
        "--darwin-deployment-version",
        help="minimum deployment target version for macOS",
        metavar="MAJOR.MINOR",
        default="10.9")

    parser.add_argument(
        "--extra-cmake-options",
        help="Pass through extra options to CMake in the form of comma "
             "separated options '-DCMAKE_VAR1=YES,-DCMAKE_VAR2=/tmp'. Can be "
             "called multiple times to add multiple such options.",
        action=arguments.action.concat,
        type=arguments.type.shell_split,
        default=[])

    parser.add_argument(
        "--build-args",
        help="arguments to the build tool. This would be prepended to the "
             "default argument that is '-j8' when CMake generator is "
             "\"Ninja\".",
        type=arguments.type.shell_split,
        default=[])

    args = migration.parse_args(parser, sys.argv[1:])

    # Set the dry run setting of the shell utilities.
    shell.dry_run = args.dry_run

    # Apply the default values of the arguments to the args namespace.
    apply_default_arguments(args=args)

    # Create a dictionary for saving the version also by simple strings.
    args.version_info = {}

    # Apply the default versions of the dependencies.
    apply_default_version_arguments(args=args)

    # Check the validity of the arguments.
    validate_arguments(args=args)

    # Set the C++ standard version to c++latest if it is set to latest so the
    # script does not have to deal with two different values for the same
    # functionality.
    if args.std == 'latest':
        args.std = 'c++latest'

    # Create the workspace object containing the build-related directories.
    workspace = Workspace(args=args,
                          source_root=ANTHEM_SOURCE_ROOT,
                          build_root=os.path.join(ANTHEM_BUILD_ROOT,
                                                  args.build_subdir),
                          install_root=os.path.join(ANTHEM_BUILD_ROOT,
                                                    args.install_prefix))

    # Clean build directory if requested.
    if args.clean:
        clean_delay()

    # Clean build directory if requested.
    if args.clean_build:
        shell.rmtree(workspace.build_root)

        if not args.build_only:
            shell.rmtree(workspace.install_root)

    # Create the build directory.
    shell.makedirs(workspace.build_root)

    # Create the install directory.
    shell.makedirs(workspace.install_root)

    # Register the tools to the toolchain.
    register_tools(args=args)

    # Prepare and validate the toolchain.
    toolchain = host_toolchain(xcrun_toolchain=args.darwin_xcrun_toolchain)
    os.environ['TOOLCHAINS'] = args.darwin_xcrun_toolchain

    if args.host_cc is not None:
        toolchain.cc = args.host_cc

    if args.host_cxx is not None:
        toolchain.cxx = args.host_cxx

    if args.msbuild is not None:
        toolchain.msbuild = args.msbuild

    if args.cmake is not None:
        toolchain.cmake = args.cmake

    # Apply the default checkout skipping options after the script knows which
    # tools are on the system already.
    apply_default_checkout_skip_arguments(args=args, toolchain=toolchain)

    # Update the checkout.
    if not args.build_only and not args.test_only:
        checkout.update(args)

    # Do not continue further if the script should only update the checkout.
    if args.update_checkout_only:
        return 0

    # Build ninja if required, which will update the toolchain.
    if (args.build_ninja
        or (args.cmake_generator == 'Ninja'
            and toolchain.ninja is None)) and not args.test_only:
        ninja.build(args=args, toolchain=toolchain, workspace=workspace)

    # Build CMake.
    if (args.build_cmake or toolchain.cmake is None) and not args.test_only:
        cmake.build(args=args, toolchain=toolchain, workspace=workspace)

    # Build LLVM, Clang, and libc++.
    if args.build_llvm and not args.test_only:
        llvm.build(args=args, toolchain=toolchain, workspace=workspace)

    # Build GCC.
    if args.build_gcc and not args.test_only:
        gcc.build(args=args, toolchain=toolchain, workspace=workspace)

    # If the main tool for build is MSBuild and CC and CXX are set to None,
    # set them as the MSBuild executable.
    if args.main_tool == 'msbuild':
        if toolchain.cc is None:
            toolchain.cc = toolchain.msbuild
        if toolchain.cxx is None:
            toolchain.cxx = toolchain.msbuild

    diagnostics.note('The host C compiler is set to ' + str(toolchain.cc))
    diagnostics.note('The host C++ compiler is set to ' + str(toolchain.cxx))
    diagnostics.note('MSBuild is set to ' + str(toolchain.msbuild))
    diagnostics.note('Ninja is set to ' + str(toolchain.ninja))
    diagnostics.note('CMake is set to ' + str(toolchain.cmake))

    # Tell the user that this set-up will not build the final product but
    # rather only set it up for CLion.
    if args.clion:
        diagnostics.note('The CLion set-up is enabled and, thus, the final '
                         'Unsung Anthem executable will not be built')

    # Build GLFW.
    if not args.build_only and not args.test_only:
        # Build GLFW.
        glfw.build(args=args, toolchain=toolchain, workspace=workspace)

    # Copy the files of the Unsung Anthem dependencies to the correct
    # directories.
    if not args.build_only and not args.test_only:
        cat.build(args=args, toolchain=toolchain, workspace=workspace)
        spdlog.build(args=args, toolchain=toolchain, workspace=workspace)

    # Copy the files of the Unsung Anthem test dependencies to the correct
    # directories.
    if args.clion or (args.build_test
                      and not args.build_only
                      and not args.test_only):
        catch.build(args=args, toolchain=toolchain, workspace=workspace)

    # Build Unsung Anthem.
    if not args.install_only and not args.test_only:
        anthem.build(args=args, toolchain=toolchain, workspace=workspace)

    # Build the Unsung Anthem tests.
    if args.build_test and not args.install_only and not args.test_only:
        anthem.build(args=args,
                     toolchain=toolchain,
                     workspace=workspace,
                     tests=True)

    # Run the tests.
    if (args.test
            or args.test_only) \
            and not args.build_only and not args.install_only:
        with shell.pushd(workspace.build_dir(args.host_target,
                                             'anthem-test',
                                             False)):
            shell.call_without_sleeping([os.path.join(
                workspace.build_dir(args.host_target, 'anthem-test', False),
                args.test_executable_name)])

    return 0


def main():
    """
    The entry point function of the script.

    :return:
    """
    # First check if the root directory environment variable of the build is
    # set.
    if not ANTHEM_SOURCE_ROOT:
        diagnostics.fatal("could not infer source root directory (forgot to "
                          "set $ANTHEM_SOURCE_ROOT environment variable?)")

    # Then check if the root directory of the build exists and is a directory.
    if not os.path.isdir(ANTHEM_SOURCE_ROOT):
        diagnostics.fatal("source root directory \'"
                          + ANTHEM_SOURCE_ROOT
                          + "\' does not exist (forgot to set "
                            "$ANTHEM_SOURCE_ROOT environment variable?)")

    # Determine if the script is invoked in the preset mode and dispatch
    # accordingly.
    if any([(opt.startswith("--preset") or opt == "--show-presets")
            for opt in sys.argv[1:]]):
        return main_preset()
    else:
        return main_normal()


if __name__ == '__main__':
    sys.exit(main())
